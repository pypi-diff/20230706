# Comparing `tmp/rafaelmicro_matter_tool-0.0.0-py3-none-any.whl.zip` & `tmp/rafaelmicro_matter_tool-0.0.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,29 @@
-Zip file size: 20415 bytes, number of entries: 27
--rw-r--r--  2.0 unx      418 b- defN 23-Jun-05 03:21 matter_tool/__init__.py
--rw-r--r--  2.0 unx      189 b- defN 23-Jun-05 03:21 matter_tool/__main__.py
--rw-r--r--  2.0 unx     5579 b- defN 23-Jun-05 03:21 matter_tool/cli.py
--rw-r--r--  2.0 unx      339 b- defN 23-Jun-05 03:21 matter_tool/error.py
--rw-r--r--  2.0 unx    35357 b- defN 23-Jun-05 03:21 matter_tool/api/ChipToolMgr.py
--rw-r--r--  2.0 unx     2009 b- defN 23-Jun-05 03:21 matter_tool/api/OTBRMgr.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/api/__init__.py
--rw-r--r--  2.0 unx     1730 b- defN 23-Jun-05 03:21 matter_tool/api/struct/ChipToolData.py
--rw-r--r--  2.0 unx      658 b- defN 23-Jun-05 03:21 matter_tool/api/struct/OTBRData.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/api/struct/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/extlib/__init__.py
--rw-r--r--  2.0 unx     1112 b- defN 23-Jun-05 03:21 matter_tool/extlib/CMDAccess/CMDAccess.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/extlib/CMDAccess/__init__.py
--rw-r--r--  2.0 unx      619 b- defN 23-Jun-05 03:21 matter_tool/extlib/CMDAccess/struct/CMD_data.py
--rw-r--r--  2.0 unx      619 b- defN 23-Jun-05 03:21 matter_tool/extlib/CMDAccess/struct/ChipToolData.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/extlib/CMDAccess/struct/__init__.py
--rw-r--r--  2.0 unx     1337 b- defN 23-Jun-05 03:21 matter_tool/extlib/TyperExt/TyperExt.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/extlib/TyperExt/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/module/__init__.py
--rw-r--r--  2.0 unx     5769 b- defN 23-Jun-05 03:21 matter_tool/module/data/Database.py
--rw-r--r--  2.0 unx    14917 b- defN 23-Jun-05 03:21 matter_tool/module/data/MatterDM.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-05 03:21 matter_tool/module/data/__init__.py
--rw-r--r--  2.0 unx     7199 b- defN 23-Jun-05 03:31 rafaelmicro_matter_tool-0.0.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-05 03:31 rafaelmicro_matter_tool-0.0.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       77 b- defN 23-Jun-05 03:31 rafaelmicro_matter_tool-0.0.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       12 b- defN 23-Jun-05 03:31 rafaelmicro_matter_tool-0.0.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2441 b- defN 23-Jun-05 03:31 rafaelmicro_matter_tool-0.0.0.dist-info/RECORD
-27 files, 80473 bytes uncompressed, 16361 bytes compressed:  79.7%
+Zip file size: 22147 bytes, number of entries: 27
+-rw-rw-r--  2.0 unx      418 b- defN 23-Jun-29 02:43 matter_tool/__init__.py
+-rw-rw-r--  2.0 unx      189 b- defN 23-Jun-29 02:43 matter_tool/__main__.py
+-rw-rw-r--  2.0 unx    10361 b- defN 23-Jul-06 02:57 matter_tool/cli.py
+-rw-rw-r--  2.0 unx      339 b- defN 23-Jun-29 02:43 matter_tool/error.py
+-rw-rw-r--  2.0 unx    47662 b- defN 23-Jul-06 05:29 matter_tool/api/ChipToolMgr.py
+-rw-rw-r--  2.0 unx     1962 b- defN 23-Jul-05 16:05 matter_tool/api/OTBRMgr.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/api/__init__.py
+-rw-rw-r--  2.0 unx     2802 b- defN 23-Jul-06 03:17 matter_tool/api/struct/ChipToolData.py
+-rw-rw-r--  2.0 unx      870 b- defN 23-Jun-30 05:49 matter_tool/api/struct/OTBRData.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/api/struct/__init__.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/extlib/__init__.py
+-rw-rw-r--  2.0 unx     1098 b- defN 23-Jul-05 16:58 matter_tool/extlib/CMDAccess/CMDAccess.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/extlib/CMDAccess/__init__.py
+-rw-rw-r--  2.0 unx      619 b- defN 23-Jun-29 02:43 matter_tool/extlib/CMDAccess/struct/CMD_data.py
+-rw-rw-r--  2.0 unx      619 b- defN 23-Jun-29 02:43 matter_tool/extlib/CMDAccess/struct/ChipToolData.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/extlib/CMDAccess/struct/__init__.py
+-rw-rw-r--  2.0 unx     1114 b- defN 23-Jul-05 10:01 matter_tool/extlib/TyperExt/TyperExt.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/extlib/TyperExt/__init__.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/module/__init__.py
+-rw-rw-r--  2.0 unx     4536 b- defN 23-Jul-05 13:41 matter_tool/module/data/Database.py
+-rw-rw-r--  2.0 unx    13469 b- defN 23-Jul-05 16:51 matter_tool/module/data/MatterDM.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-Jun-29 02:43 matter_tool/module/data/__init__.py
+-rw-rw-r--  2.0 unx     9761 b- defN 23-Jul-06 07:18 rafaelmicro_matter_tool-0.0.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jul-06 07:18 rafaelmicro_matter_tool-0.0.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       77 b- defN 23-Jul-06 07:18 rafaelmicro_matter_tool-0.0.1.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       12 b- defN 23-Jul-06 07:18 rafaelmicro_matter_tool-0.0.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2442 b- defN 23-Jul-06 07:18 rafaelmicro_matter_tool-0.0.1.dist-info/RECORD
+27 files, 98442 bytes uncompressed, 18093 bytes compressed:  81.6%
```

## zipnote {}

```diff
@@ -60,23 +60,23 @@
 
 Filename: matter_tool/module/data/MatterDM.py
 Comment: 
 
 Filename: matter_tool/module/data/__init__.py
 Comment: 
 
-Filename: rafaelmicro_matter_tool-0.0.0.dist-info/METADATA
+Filename: rafaelmicro_matter_tool-0.0.1.dist-info/METADATA
 Comment: 
 
-Filename: rafaelmicro_matter_tool-0.0.0.dist-info/WHEEL
+Filename: rafaelmicro_matter_tool-0.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: rafaelmicro_matter_tool-0.0.0.dist-info/entry_points.txt
+Filename: rafaelmicro_matter_tool-0.0.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: rafaelmicro_matter_tool-0.0.0.dist-info/top_level.txt
+Filename: rafaelmicro_matter_tool-0.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: rafaelmicro_matter_tool-0.0.0.dist-info/RECORD
+Filename: rafaelmicro_matter_tool-0.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## matter_tool/cli.py

```diff
@@ -2,44 +2,63 @@
 from typing import Optional
 from .api.ChipToolMgr import ChipToolMgr
 from .api.ChipToolMgr import ChipToolLightMgr
 from .api.ChipToolMgr import ChipToolSwitchMgr
 from .api.ChipToolMgr import ChipToolConnectMgr
 from .api.OTBRMgr import OTBRMgr
 from .api.struct import OTBRData as CMDhelpper
+from .extlib.MgmtExt.log import set_log_level, get_logger
+from .extlib.MgmtExt.time import start_timmer, stop_timmer
 from . import __app_name__, __version__
 
 app = typer.Typer()
 
+
+def check_log_level(flag):
+    if flag == True:
+        set_log_level("DEBUG")
+    else:
+        set_log_level("INFO")
+
 ### Thread Command ###
 
 
 @app.command(name="state")
-def get_state() -> None:
+def get_state(
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Thread] Get Thread Network state."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     OTBRMgr().handle_command(CMDhelpper.QueryCMDMapper.STATE)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 @app.command(name="dataset")
 def get_dataset(
         hex: Optional[int] = typer.Option(
             0, "--hex", "-x",
             help="BLE adapter with HCI device [int]",
-        )) -> None:
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Thread] Get Thread active dataset."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     if (hex == 0):
         OTBRMgr().handle_command(CMDhelpper.QueryCMDMapper.DATA)
     else:
         OTBRMgr().handle_command(CMDhelpper.QueryCMDMapper.HEX)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
-### Matter Command ###
 
+### Matter Command ###
 
 @app.command(name="connect")
-def pair_thread(
+def connect(
         name: Optional[str] = typer.Argument(
             None, help="device alias",
         ),
         devicetype: Optional[str] = typer.Argument(
             None, help="device type",
         ),
         pincode: Optional[str] = typer.Argument(
@@ -47,137 +66,236 @@
         ),
         discriminator: Optional[int] = typer.Argument(
             None, help="device long discriminator",
         ),
         ble_adapter: Optional[int] = typer.Option(
             0, "--ble-adapter", "-b",
             help="BLE adapter with HCI device [int]",
-        ), ) -> None:
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] Pair device with Thread."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     ChipToolConnectMgr().connect(name, devicetype, pincode, discriminator, ble_adapter)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
-@app.command(name="gen_group")
-def gen_group(
-    group_name: Optional[str] = typer.Argument(
-        None, help="Group name",
-    ),
-) -> None:
+@app.command(name="disconnect")
+def disconnect(
+        name: Optional[str] = typer.Argument(
+            None, help="device alias",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] Unpair device with Thread."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolConnectMgr().disconnect(name)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
+
+
+@app.command(name="reset")
+def reset(
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] Reset matter-tool (Factory reset devices first)"""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolConnectMgr().reset()
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
+
+
+@app.command(name="group_gen")
+def group_gen(
+        group_name: Optional[str] = typer.Argument(
+            None, help="Group name",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] Generate group."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     ChipToolSwitchMgr().gen_group(group_name)
-    return
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
-@app.command(name="add_group")
-def add_group(
-    group_name: Optional[str] = typer.Argument(
-        None, help="Group name",
-    ),
-    target_type: Optional[str] = typer.Argument(
-        None, help="target device type",
-    ),
-    target_name: Optional[str] = typer.Argument(
-        None, help="Connected target name",
-    ),
-    target_endpoint: Optional[int] = typer.Option(
-        1, "--target-endpoint", "-l",
-        help="target endpoint",
-    ),
-) -> None:
-    """[Matter] Add device to group."""
-    ChipToolSwitchMgr().add_group(group_name, target_type, target_name, target_endpoint)
-    return
+@app.command(name="group_del")
+def group_del(
+        group_name: Optional[str] = typer.Argument(
+            None, help="Group name",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] Delete group."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolSwitchMgr().del_group(group_name)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
+
+
+@app.command(name="group_join")
+def group_join(
+        group_name: Optional[str] = typer.Argument(
+            None, help="Group name",
+        ),
+        target_name: Optional[str] = typer.Argument(
+            None, help="Connected target name",
+        ),
+        target_endpoint: Optional[int] = typer.Option(
+            1, "--target-endpoint", "-l",
+            help="target endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] join device to group."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolSwitchMgr().join_group(group_name, target_name, target_endpoint)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
+
+
+@app.command(name="group_leave")
+def group_leave(
+        group_name: Optional[str] = typer.Argument(
+            None, help="Group name",
+        ),
+        target_name: Optional[str] = typer.Argument(
+            None, help="Connected target name",
+        ),
+        target_endpoint: Optional[int] = typer.Option(
+            1, "--target-endpoint", "-l",
+            help="target endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] leave device to group."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolSwitchMgr().leave_group(
+        group_name, target_name, target_endpoint)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 @app.command(name="onoff")
-def get_state(
-    action: Optional[str] = typer.Argument(
-        'on', help="control light: [on/off/toggle]",
-    ),
-    light_name: Optional[str] = typer.Argument(
-        None, help="target light name",
-    ),
-    endpoint: Optional[int] = typer.Argument(
-        1, help="target endpoint",
-    ),
-) -> None:
+def onoff(
+        action: Optional[str] = typer.Argument(
+            'on', help="control light: [on/off/toggle]",
+        ),
+        light_name: Optional[str] = typer.Argument(
+            None, help="target light name",
+        ),
+        endpoint: Optional[int] = typer.Argument(
+            1, help="target endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] Onoff control Matter Light."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     ChipToolLightMgr().onoff(action, light_name, endpoint)
-    return
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
+
+
+@app.command(name="group_onoff")
+def group_onoff(
+        action: Optional[str] = typer.Argument(
+            'on', help="control light: [on/off/toggle]",
+        ),
+        group_name: Optional[str] = typer.Argument(
+            None, help="target group name",
+        ),
+        endpoint: Optional[int] = typer.Argument(
+            1, help="target endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
+    """[Matter] Group onoff control Matter Light."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    ChipToolLightMgr().group_onoff(action, group_name, endpoint)
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 @app.command(name="level")
-def get_state(
-    level: Optional[int] = typer.Argument(
-        0, help="target level",
-    ),
-    transition: Optional[int] = typer.Option(
-        0, "--transition", "-t",
-        help="transitiontime",
-    ),
-    light_name: Optional[str] = typer.Argument(
-        None, help="target light name",
-    ),
-    endpoint: Optional[int] = typer.Argument(
-        1, help="target endpoint",
-    ),
-) -> None:
+def level(
+        level: Optional[int] = typer.Argument(
+            0, help="target level",
+        ),
+        transition: Optional[int] = typer.Option(
+            0, "--transition", "-t",
+            help="transitiontime",
+        ),
+        light_name: Optional[str] = typer.Argument(
+            None, help="target light name",
+        ),
+        endpoint: Optional[int] = typer.Argument(
+            1, help="target endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] level control Matter Light."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     ChipToolLightMgr().level(level, light_name, endpoint, transition)
-    return
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 @app.command(name="show")
-def get_state(
-    display: Optional[int] = typer.Option(
-        0, "--display-level", "-d",
-        help="""
-        Matter Profile Level:\n
-        level 0 (default): display node profile\n
-        level 1: display Matter profile\n
-        level 2: display Matter profile and Matter stack information\n
-        """,
-    )
-) -> None:
+def show(
+        display: Optional[int] = typer.Option(
+            0, "--level", "-l",
+            help="""
+            Matter Profile Level:\n
+            level 0 (default): display node profile\n
+            level 1: display Matter profile and Matter stack information\n
+            """,
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] show matter profile"""
-    if (display == 1):
-        ChipToolMgr().list_node_profile()
-    elif (display == 1):
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
+    if (display == 0):
         ChipToolMgr().list_node_profile()
         ChipToolMgr().list_binding_profile()
         ChipToolMgr().list_group_mapper_profile()
-    elif (display == 2):
+    elif (display == 1):
         ChipToolMgr().list_node_profile()
         ChipToolMgr().list_binding_profile()
         ChipToolMgr().list_group_mapper_profile()
         ChipToolMgr().list_acl_profile()
         ChipToolMgr().list_group_profile()
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 @app.command(name="bind")
-def get_state(
-    light_name: Optional[str] = typer.Argument(
-        None, help="Connected light name",
-    ),
-    light_endpoint: Optional[int] = typer.Option(
-        1, "--light-endpoint", "-l",
-        help="target light endpoint",
-    ),
-    switch_name: Optional[str] = typer.Argument(
-        None, help="Connected switch name",
-    ),
-    switch_endpoint: Optional[int] = typer.Option(
-        1, "--switch-endpoint", "-s",
-        help="target switch endpoint",
-    ),
-) -> None:
+def bind(
+        light_name: Optional[str] = typer.Argument(
+            None, help="Connected light name",
+        ),
+        light_endpoint: Optional[int] = typer.Option(
+            1, "--light-endpoint", "-l",
+            help="target light endpoint",
+        ),
+        switch_name: Optional[str] = typer.Argument(
+            None, help="Connected switch name",
+        ),
+        switch_endpoint: Optional[int] = typer.Option(
+            1, "--switch-endpoint", "-s",
+            help="target switch endpoint",
+        ),
+        is_debug: bool = typer.Option(False, "--debug", "-d"),) -> None:
     """[Matter] Set binding between light and switch."""
+    check_log_level(is_debug)
+    _logger = get_logger("APP")
+    start_timmer("CMD")
     ChipToolSwitchMgr().set_binding(
         light_name, light_endpoint, switch_name, switch_endpoint)
-    return
+    _logger.info("Execute time: " + str(stop_timmer("CMD")))
 
 
 def _version_callback(value: bool) -> None:
     if value:
         typer.echo(f"{__app_name__} v{__version__}")
         raise typer.Exit()
```

## matter_tool/api/ChipToolMgr.py

```diff
@@ -1,34 +1,37 @@
 from enum import Enum
 import json
 import re
+import os
+import glob
+import dataclasses
+import time
 from prettytable import PrettyTable
 from .OTBRMgr import OTBRMgr
 from ..extlib.CMDAccess.CMDAccess import CMDAccess
-from ..extlib.TyperExt.TyperExt import TyperExt
+from ..extlib.MgmtExt.log import get_logger
+from ..extlib.MgmtExt.time import stop_timmer
 from ..module.data.MatterDM import MatterDM
+from ..module.data.Database import DatabaseHandler
 from .struct import OTBRData as OTBRhelpper
 from .struct import ChipToolData as ChipToolhelpper
-import dataclasses
 from dataclasses import dataclass
 
 
 class ChipToolMgr:
     def __init__(self) -> None:
-        self._TyperExt = TyperExt()
         self._OTBRMgr = OTBRMgr()
         self._MatterDM = MatterDM()
+        self._logger = get_logger("APP")
 
     def get_thread_network(self) -> None:
         return self._OTBRMgr.handle_command(OTBRhelpper.QueryCMDMapper.HEX)
 
     def list_node_profile(self):
-        self._TyperExt.attach_log(
-            "=== [Matter Profile] Node ===",
-            self._TyperExt.Colors.BRIGHT_YELLOW)
+        self._logger.info("=== [Matter Profile] Node ===")
         self.clear_failed_data()
         node_list = self._MatterDM.get_node_list()
         nodeid = []
         name = []
         devicetype = []
         status = []
         fabric = []
@@ -40,20 +43,18 @@
             fabric.append(node["fabric"])
         tab = PrettyTable()
         tab.add_column('nodeid', nodeid, align='r', valign='t')
         tab.add_column('name', name, align='r', valign='t')
         tab.add_column('devicetype', devicetype, align='r', valign='t')
         tab.add_column('status', status, align='r', valign='t')
         tab.add_column('fabric', fabric, align='r', valign='t')
-        self._TyperExt.attach_log(tab, self._TyperExt.Colors.GREEN)
+        self._logger.info("\n"+str(tab))
 
     def list_binding_profile(self):
-        self._TyperExt.attach_log(
-            "=== [Matter Profile] Binding List ===",
-            self._TyperExt.Colors.BRIGHT_YELLOW)
+        self._logger.info("=== [Matter Profile] Binding List ===")
         self.clear_failed_data()
         binding_list = self._MatterDM.get_fully_binding_list()
         name = []
         fabric = []
         nodeid = []
         target_name = []
         target_id = []
@@ -68,20 +69,18 @@
         tab = PrettyTable()
         tab.add_column('name', name, align='r', valign='t')
         tab.add_column('fabric', fabric, align='r', valign='t')
         tab.add_column('nodeid', nodeid, align='r', valign='t')
         tab.add_column('target_name', target_name, align='r', valign='t')
         tab.add_column('target_id', target_id, align='r', valign='t')
         tab.add_column('endpoint', endpoint, align='r', valign='t')
-        self._TyperExt.attach_log(tab, self._TyperExt.Colors.GREEN)
+        self._logger.info("\n"+str(tab))
 
     def list_group_mapper_profile(self):
-        self._TyperExt.attach_log(
-            "=== [Matter Profile] Group Mapper List ===",
-            self._TyperExt.Colors.BRIGHT_YELLOW)
+        self._logger.info("=== [Matter Profile] Group Mapper List ===")
         self.clear_failed_data()
         group_mapper_list = self._MatterDM.get_fully_group_mapper_list()
         name = []
         group_id = []
         target_id = []
         target_name = []
         target_type = []
@@ -100,20 +99,18 @@
         tab.add_column('group_id', group_id, align='r', valign='t')
         tab.add_column('target_id', target_id, align='r', valign='t')
         tab.add_column('target_name', target_name, align='r', valign='t')
         tab.add_column('target_type', target_type, align='r', valign='t')
         tab.add_column('target_endpoint', target_endpoint,
                        align='r', valign='t')
         tab.add_column('status', status, align='r', valign='t')
-        self._TyperExt.attach_log(tab, self._TyperExt.Colors.GREEN)
+        self._logger.info("\n"+str(tab))
 
     def list_acl_profile(self):
-        self._TyperExt.attach_log(
-            "=== [Matter Stack] Access Control List ===",
-            self._TyperExt.Colors.BRIGHT_YELLOW)
+        self._logger.info("=== [Matter Stack] Access Control List ===")
         self.clear_failed_data()
         acl_list = self._MatterDM.get_fully_acl_list()
         name = []
         fabric = []
         nodeid = []
         target_name = []
         target_id = []
@@ -131,20 +128,18 @@
         tab.add_column('name', name, align='r', valign='t')
         tab.add_column('fabric', fabric, align='r', valign='t')
         tab.add_column('nodeid', nodeid, align='r', valign='t')
         tab.add_column('target_name', target_name, align='r', valign='t')
         tab.add_column('target_id', target_id, align='r', valign='t')
         tab.add_column('privilege', privilege, align='r', valign='t')
         tab.add_column('auto_mode', auto_mode, align='r', valign='t')
-        self._TyperExt.attach_log(tab, self._TyperExt.Colors.GREEN)
+        self._logger.info("\n"+str(tab))
 
     def list_group_profile(self):
-        self._TyperExt.attach_log(
-            "=== [Matter Stack] Access Control List ===",
-            self._TyperExt.Colors.BRIGHT_YELLOW)
+        self._logger.info("=== [Matter Stack] Group Setting List ===")
         self.clear_failed_data()
         group_list = self._MatterDM.get_fully_group_list()
         name = []
         group_id = []
         group_keyset_id = []
         epochkey0 = []
         epochkey1 = []
@@ -160,15 +155,15 @@
         tab.add_column('name', name, align='r', valign='t')
         tab.add_column('group_id', group_id, align='r', valign='t')
         tab.add_column('group_keyset_id', group_keyset_id,
                        align='r', valign='t')
         tab.add_column('epochkey0', epochkey0, align='r', valign='t')
         tab.add_column('epochkey1', epochkey1, align='r', valign='t')
         tab.add_column('epochkey2', epochkey2, align='r', valign='t')
-        self._TyperExt.attach_log(tab, self._TyperExt.Colors.GREEN)
+        self._logger.info("\n"+str(tab))
 
     def get_profile(self, name):
         return self._MatterDM.get_node("name", name)
 
     def get_acl(self, name):
         return self._MatterDM.get_acl_list("name", name)
 
@@ -229,56 +224,108 @@
 
     def update_profile(self, node):
         self._MatterDM.update_node(node)
 
     def update_group_profile(self, group):
         self._MatterDM.update_group_mapper(group)
 
-    def unique_profile(self, target, key):
-        return list(set(item[key] for item in target))
+    def delete_group(self, name):
+        self._MatterDM.delete_match("group", "name", name)
+        self._MatterDM.delete_match("group_mapper", "name", name)
+
+    def delete_group_mapper(self, name, nodeid, endpoint):
+        delete_count = self._MatterDM.delete_multi_match("group_mapper", {
+            "name": name,
+            "target_id": str(nodeid),
+            "target_endpoint": str(endpoint),
+        })
+        self._logger.info(str(delete_count))
+
+    def delete_group_acl(self, name, fabric, nodeid, auto_mode):
+        self._MatterDM.delete_multi_match("acl", {
+            "name": name, "fabric": fabric, "nodeid": nodeid, "auto_mode": auto_mode
+        })
+
+    def clear_profile(self, node):
+        self._MatterDM.delete_match("node", "name", node["name"])
+        self._MatterDM.delete_match("acl", "name", node["name"])
+        self._MatterDM.delete_match("acl", "target_name", node["name"])
+        self._MatterDM.delete_match("binding", "name", node["name"])
+        self._MatterDM.delete_match("binding", "target_name", node["name"])
+        self._MatterDM.delete_match(
+            "group_mapper", "target_name", node["name"])
 
     def clear_failed_data(self):
-        self._MatterDM.clear_failed_node()
-        self._MatterDM.clear_failed_group_mapper()
+        self._MatterDM.delete_mismatch("node", "status", "Connected")
+        self._MatterDM.delete_mismatch("group_mapper", "status", "Success")
+
+    def unique_profile(self, target, key):
+        return list(set(item[key] for item in target))
 
 
 class ChipToolLightMgr:
     class OnoffAction(Enum):
         ON = 'on'
         OFF = 'off'
         TOGGLE = 'toggle'
 
     def __init__(self) -> None:
-        self._TyperExt = TyperExt()
         self._CMDAccess = CMDAccess()
         self._ChipToolMgr = ChipToolMgr()
+        self._logger = get_logger("APP")
 
     def onoff_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(ChipToolhelpper.CMDList.LIGHT_ONOFF.value + [
+            str(kwargs["contain"]["action"]),
+            str(kwargs["contain"]["nodeid"]),
+            str(kwargs["contain"]["endpoint"])
+        ]))
         return ChipToolhelpper.CMDList.LIGHT_ONOFF.value + [
             str(kwargs["contain"]["action"]),
             str(kwargs["contain"]["nodeid"]),
             str(kwargs["contain"]["endpoint"])
         ]
 
+    def group_onoff_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(ChipToolhelpper.CMDList.LIGHT_GROUP_ONOFF.value[0:2] + [
+            str(kwargs["contain"]["action"]),
+            "0xffffffffffff" +
+            str(hex(kwargs["contain"]["group_id"])[2:].zfill(4)),
+            str(kwargs["contain"]["endpoint"])
+        ]))
+        return ChipToolhelpper.CMDList.LIGHT_GROUP_ONOFF.value[0:2] + [
+            str(kwargs["contain"]["action"]),
+            "0xffffffffffff" +
+            str(hex(kwargs["contain"]["group_id"])[2:].zfill(4)),
+            str(kwargs["contain"]["endpoint"])
+        ]
+
     def level_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(ChipToolhelpper.CMDList.LEVEL_CTL.value + [
+            str(kwargs["contain"]["level"]),
+            str(kwargs["contain"]["transition"]),
+            "0", "0",
+            str(kwargs["contain"]["nodeid"]),
+            str(kwargs["contain"]["endpoint"])
+        ]))
         return ChipToolhelpper.CMDList.LEVEL_CTL.value + [
             str(kwargs["contain"]["level"]),
             str(kwargs["contain"]["transition"]),
             "0", "0",
             str(kwargs["contain"]["nodeid"]),
             str(kwargs["contain"]["endpoint"])
         ]
 
     def acl_passer(self, *args, **kwargs) -> None:
-        # self._TyperExt.attach_log(json.dumps(
-        #     ChipToolhelpper.CMDList.SET_ACL.value + [
-        #         kwargs["contain"]["acl"],
-        #         str(kwargs["contain"]["light_id"]),
-        #         str(kwargs["contain"]["endpoint"])
-        #     ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug(json.dumps(
+            ChipToolhelpper.CMDList.SET_ACL.value + [
+                kwargs["contain"]["acl"],
+                str(kwargs["contain"]["light_id"]),
+                str(kwargs["contain"]["endpoint"])
+            ]))
         return ChipToolhelpper.CMDList.SET_ACL.value + [
             kwargs["contain"]["acl"],
             str(kwargs["contain"]["light_id"]),
             str(kwargs["contain"]["endpoint"])
         ]
 
     def acl_json_passer(self, acl_list) -> None:
@@ -297,292 +344,389 @@
                     "privilege": 5, "authMode": 2,
                     "subjects": [acl['target_id']], "targets": None
                 })
             elif (acl["privilege"] == 3 and acl["auto_mode"] == 2):
                 rsp[0]["subjects"].append(acl['target_id'])
             elif (acl["privilege"] == 3 and acl["auto_mode"] == 3):
                 rsp[1]["subjects"].append(acl['target_id'])
-        # self._TyperExt.attach_log(
-        #     "="*50, self._TyperExt.Colors.BRIGHT_MAGENTA)
-        # self._TyperExt.attach_log(json.dumps(
-        #     rsp), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug("="*50)
+        self._logger.debug(json.dumps(rsp))
         return json.dumps(rsp)
 
     def command_passer(self, context_type, *args, **kwargs) -> None:
         cancat_dict = {
             ChipToolhelpper.QueryCMDMapper.LIGHT_ONOFF: self.onoff_passer,
+            ChipToolhelpper.QueryCMDMapper.LIGHT_GROUP_ONOFF: self.group_onoff_passer,
             ChipToolhelpper.QueryCMDMapper.LEVEL_CONTROL: self.level_passer,
             ChipToolhelpper.QueryCMDMapper.ACCESS_CONTROL: self.acl_passer,
         }
         return cancat_dict[context_type](contain=kwargs["contain"])
 
     def handle_command(self, context_type: ChipToolhelpper.QueryCMDMapper, *args, **kwargs) -> None:
         command = self.command_passer(context_type, contain=kwargs)
         status, result = self._CMDAccess.send_command(command)
         return status, result
 
     def onoff(self, action, light_name, endpoint) -> None:
         self._ChipToolMgr.clear_failed_data()
         if not (any(x for x in self.OnoffAction if x.value == action)):
-            self._TyperExt.raise_error(1, 'Invailed action type')
+            self._logger.error("Invailed action type")
+
+        self._logger.info("Stage: Send onoff")
         light_node = self._ChipToolMgr.get_profile(light_name)
         status, result = self.handle_command(ChipToolhelpper.QueryCMDMapper.LIGHT_ONOFF,
                                              action=action, nodeid=light_node['nodeid'],
                                              endpoint=endpoint)
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Connect failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Connect failed")
+        self._logger.info("The node: " + light_name +
+                          ", action: " + str(action))
 
-        self._TyperExt.attach_log("The node: " + light_name + ", action: " + str(action),
-                                  self._TyperExt.Colors.GREEN)
+    def group_onoff(self, action, group_name, endpoint) -> None:
+        self._ChipToolMgr.clear_failed_data()
+        if not (any(x for x in self.OnoffAction if x.value == action)):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Invailed action type")
+
+        self._logger.info("Stage: Send Group onoff")
+        group = self._ChipToolMgr.get_group("name", group_name)
+        status, result = self.handle_command(ChipToolhelpper.QueryCMDMapper.LIGHT_GROUP_ONOFF,
+                                             action=action, group_id=group['group_id'],
+                                             endpoint=endpoint)
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Connect failed")
+        self._logger.info("The node: " + group_name +
+                          ", action: " + str(action))
 
     def level(self, level, light_name, endpoint, transition) -> None:
         self._ChipToolMgr.clear_failed_data()
         light_node = self._ChipToolMgr.get_profile(light_name)
+
+        self._logger.info("Stage: Send Level Control")
         status, result = self.handle_command(ChipToolhelpper.QueryCMDMapper.LEVEL_CONTROL,
                                              level=level, nodeid=light_node['nodeid'],
                                              transition=transition, endpoint=endpoint)
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Connect failed')
-
-        self._TyperExt.attach_log("The node: " + light_name + ", set level: " + str(level),
-                                  self._TyperExt.Colors.GREEN)
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Connect failed")
+        self._logger.info("The node: " + light_name +
+                          ", set level: " + str(level))
 
     def set_acl(self, light_node, switch_node) -> None:
         acl = self._ChipToolMgr.get_acl(light_node["name"])
 
         target_acl = {
             "name": light_node["name"], "fabric": light_node["fabric"],
             "nodeid": light_node["nodeid"], "target_name": switch_node["name"],
             "target_id": switch_node["nodeid"], "privilege": 3, "auto_mode": 2,
         }
         if (target_acl not in acl):
             acl.append(target_acl)
         else:
-            self._TyperExt.attach_log(
-                "ACL already existed", self._TyperExt.Colors.BRIGHT_MAGENTA)
+            self._logger.warning("ACL already existed")
 
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug(json.dumps(acl))
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.ACCESS_CONTROL,
             acl=self.acl_json_passer(acl),
             light_id=light_node["nodeid"],
             endpoint=0
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: set light ACL failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("set light ACL failed")
 
         acl = self._ChipToolMgr.new_acl_profile(
             name=light_node["name"], fabric=light_node["fabric"],
             nodeid=light_node["nodeid"], target_name=switch_node["name"],
             target_id=switch_node["nodeid"], privilege=3, auto_mode=2
         )
         self._ChipToolMgr.apply_acl_profile(acl)
 
-    def set_group_acl(self, node, group) -> None:
+    def bind_group_acl(self, node, group) -> None:
         acl = self._ChipToolMgr.get_acl(node["name"])
         target_acl = {
             "name": node["name"], "fabric": node["fabric"],
             "nodeid": node["nodeid"], "target_name": group["name"],
             "target_id": group["nodeid"], "privilege": 3, "auto_mode": 3,
         }
         if (target_acl not in acl):
             acl.append(target_acl)
         else:
-            self._TyperExt.attach_log(
-                "ACL already existed", self._TyperExt.Colors.BRIGHT_MAGENTA)
+            self._logger.warning("ACL already existed")
 
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug(json.dumps(acl))
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.ACCESS_CONTROL,
             acl=self.acl_json_passer(acl),
             light_id=node["nodeid"],
             endpoint=0
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: set light ACL failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("set light ACL failed")
 
         acl = self._ChipToolMgr.new_acl_profile(
             name=node["name"], nodeid=node["nodeid"], fabric=node["fabric"],
             target_name=group["name"], target_id=group["nodeid"],
             privilege=3, auto_mode=3
         )
         self._ChipToolMgr.apply_acl_profile(acl)
 
+    def unbind_group_acl(self, node, group) -> None:
+        self._ChipToolMgr.delete_group_acl(
+            name=node["name"], fabric=node["fabric"],
+            nodeid=node["nodeid"], auto_mode=3,
+        )
+        acl = self._ChipToolMgr.get_acl(node["name"])
+
+        self._logger.debug(json.dumps(acl))
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.ACCESS_CONTROL,
+            acl=self.acl_json_passer(acl),
+            light_id=node["nodeid"],
+            endpoint=0
+        )
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("set light ACL failed")
+
+        acl = self._ChipToolMgr.new_acl_profile(
+            name=node["name"], nodeid=node["nodeid"], fabric=node["fabric"],
+            target_name=group["name"], target_id=group["nodeid"],
+            privilege=3, auto_mode=3
+        )
+
+        self._ChipToolMgr.apply_acl_profile(acl)
+
 
 class ChipToolSwitchMgr:
     @dataclass
     class GroupKeySet():
         groupKeySetID: int
         groupKeySecurityPolicy: int
         epochKey0: str
         epochStartTime0: int
         epochKey1: str
         epochStartTime1: int
         epochKey2: str
         epochStartTime2: int
 
     def __init__(self) -> None:
-        self._TyperExt = TyperExt()
         self._CMDAccess = CMDAccess()
         self._ChipToolMgr = ChipToolMgr()
         self._ChipToolLightMgr = ChipToolLightMgr()
+        self._logger = get_logger("APP")
 
     def binding_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.WRITE_BINDING.value + [
                 kwargs["contain"]["binding_list"],
                 str(kwargs["contain"]["nodeid"]),
                 str(kwargs["contain"]["endpoint"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.WRITE_BINDING.value + [
             kwargs["contain"]["binding_list"],
             str(kwargs["contain"]["nodeid"]),
             str(kwargs["contain"]["endpoint"])
         ]
 
     def group_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.CREATE_GROUP.value + [
                 str(kwargs["contain"]["name"]),
                 str(kwargs["contain"]["group_id"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.CREATE_GROUP.value + [
             str(kwargs["contain"]["name"]),
             str(kwargs["contain"]["group_id"])
         ]
 
+    def remove_group_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.REMOVE_GROUP.value + [
+                str(kwargs["contain"]["group_id"])
+            ]))
+        return ChipToolhelpper.CMDList.REMOVE_GROUP.value + [
+            str(kwargs["contain"]["group_id"])
+        ]
+
     def keyset_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.CREATE_KEYSET.value + [
                 str(kwargs["contain"]["group_keyset_id"]),
                 str(kwargs["contain"]["groupKeySecurityPolicy"]),
                 str(kwargs["contain"]["epochStartTime0"]),
                 'hex:'+str(kwargs["contain"]["epochKey0"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.CREATE_KEYSET.value + [
             str(kwargs["contain"]["group_keyset_id"]),
             str(kwargs["contain"]["groupKeySecurityPolicy"]),
             str(kwargs["contain"]["epochStartTime0"]),
             'hex:'+str(kwargs["contain"]["epochKey0"])
         ]
 
+    def remove_keyset_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.REMOVE_KEYSET.value + [
+                str(kwargs["contain"]["group_keyset_id"]),
+            ]))
+        return ChipToolhelpper.CMDList.REMOVE_KEYSET.value + [
+            str(kwargs["contain"]["group_keyset_id"]),
+        ]
+
     def bind_group_keyset_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.BIND_GROUP_KEYSET.value + [
                 str(kwargs["contain"]["group_id"]),
                 str(kwargs["contain"]["group_keyset_id"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.BIND_GROUP_KEYSET.value + [
             str(kwargs["contain"]["group_id"]),
             str(kwargs["contain"]["group_keyset_id"])
         ]
 
+    def unbind_group_keyset_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.UNBIND_GROUP_KEYSET.value + [
+                str(kwargs["contain"]["group_id"]),
+                str(kwargs["contain"]["group_keyset_id"]),
+            ]))
+        return ChipToolhelpper.CMDList.UNBIND_GROUP_KEYSET.value + [
+            str(kwargs["contain"]["group_id"]),
+            str(kwargs["contain"]["group_keyset_id"]),
+        ]
+
     def apply_keyset_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.APPLY_KEYSET.value + [
                 kwargs["contain"]["group_key_set"],
                 str(kwargs["contain"]["target_nodeid"]),
                 str(kwargs["contain"]["target_endpoint"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.APPLY_KEYSET.value + [
             kwargs["contain"]["group_key_set"],
             str(kwargs["contain"]["target_nodeid"]),
             str(kwargs["contain"]["target_endpoint"])
         ]
 
+    def denied_keyset_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.DENIED_KEYSET.value + [
+                str(kwargs["contain"]["group_keyset_id"]),
+                str(kwargs["contain"]["target_nodeid"]),
+                "0",
+            ]))
+        return ChipToolhelpper.CMDList.DENIED_KEYSET.value + [
+            str(kwargs["contain"]["group_keyset_id"]),
+            str(kwargs["contain"]["target_nodeid"]),
+            "0",
+        ]
+
     def apply_keyset_map_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.APPLY_KEYSET_MAP.value + [
                 kwargs["contain"]["group_key_map_list"],
                 str(kwargs["contain"]["target_nodeid"]),
                 str(kwargs["contain"]["target_endpoint"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.APPLY_KEYSET_MAP.value + [
             kwargs["contain"]["group_key_map_list"],
             str(kwargs["contain"]["target_nodeid"]),
             str(kwargs["contain"]["target_endpoint"])
         ]
 
     def apply_group_passer(self, *args, **kwargs) -> None:
-        self._TyperExt.attach_log(json.dumps(
+        self._logger.info(json.dumps(
             ChipToolhelpper.CMDList.APPLY_GROUP.value + [
                 str(kwargs["contain"]["groupId"]),
                 str(kwargs["contain"]["group_name"]),
                 str(kwargs["contain"]["target_nodeid"]),
                 str(kwargs["contain"]["target_endpoint"])
-            ]), self._TyperExt.Colors.BRIGHT_MAGENTA)
+            ]))
         return ChipToolhelpper.CMDList.APPLY_GROUP.value + [
             str(kwargs["contain"]["groupId"]),
             str(kwargs["contain"]["group_name"]),
             str(kwargs["contain"]["target_nodeid"]),
             str(kwargs["contain"]["target_endpoint"])
         ]
 
+    def denied_group_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.DENIED_GROUP.value + [
+                str(kwargs["contain"]["groupId"]),
+                str(kwargs["contain"]["target_nodeid"]),
+                str(kwargs["contain"]["target_endpoint"])
+            ]))
+        return ChipToolhelpper.CMDList.DENIED_GROUP.value + [
+            str(kwargs["contain"]["groupId"]),
+            str(kwargs["contain"]["target_nodeid"]),
+            str(kwargs["contain"]["target_endpoint"])
+        ]
+
     def binding_json_passer(self, binding_list) -> None:
         rsp = []
         for binding in binding_list:
             rsp.append({
                 "fabricIndex": binding['fabric'], "node": binding["target_id"],
                 "endpoint": binding["endpoint"], "cluster": 6
             })
-        # self._TyperExt.attach_log(
-        #     "="*50, self._TyperExt.Colors.BRIGHT_MAGENTA)
-        # self._TyperExt.attach_log(json.dumps(
-        #     rsp), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug("="*50)
+        self._logger.debug(json.dumps(rsp))
         return json.dumps(rsp)
 
     def keyset_map_json_passer(self, nodeid, fabric) -> None:
         group_mapper_list = self._ChipToolMgr.get_group_mapper(
             "target_id", nodeid)
         group_list = self._ChipToolMgr.unique_profile(
             group_mapper_list, "name")
         rows = []
         for group_item in group_list:
             rows += self._ChipToolMgr.get_match_group(
                 "name", group_item)
         rsp = []
         for item in rows:
-            # self._TyperExt.attach_log(json.dumps(
-            #     item), self._TyperExt.Colors.BRIGHT_CYAN)
+            self._logger.debug(json.dumps(item))
             rsp.append({
                 "fabricIndex": fabric, "groupId": item["group_id"],
                 "groupKeySetID": item["group_keyset_id"]
             })
-        # self._TyperExt.attach_log(
-        #     "="*50, self._TyperExt.Colors.BRIGHT_MAGENTA)
-        # self._TyperExt.attach_log(json.dumps(
-        #     rsp), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug("="*50)
+        self._logger.debug(json.dumps(rsp))
         return json.dumps(rsp)
 
     def group_binding_json_passer(self, nodeid, group_id) -> None:
         group_mapper_list = self._ChipToolMgr.get_group_mapper(
             "target_id", nodeid)
         group_list = self._ChipToolMgr.unique_profile(
             group_mapper_list, "group_id")
         rsp = []
         for group in group_list:
             rsp.append({"group": group})
         rsp.append({"group": group_id})
-        # self._TyperExt.attach_log(
-        #     "="*50, self._TyperExt.Colors.BRIGHT_MAGENTA)
-        # self._TyperExt.attach_log(json.dumps(
-        #     rsp), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug("="*50)
+        self._logger.debug(json.dumps(rsp))
         return json.dumps(rsp)
 
     def command_passer(self, context_type, *args, **kwargs) -> None:
         cancat_dict = {
             ChipToolhelpper.QueryCMDMapper.SET_BINDING: self.binding_passer,
             ChipToolhelpper.QueryCMDMapper.CREATE_GROUP: self.group_passer,
+            ChipToolhelpper.QueryCMDMapper.REMOVE_GROUP: self.remove_group_passer,
             ChipToolhelpper.QueryCMDMapper.CREATE_KEYSET: self.keyset_passer,
+            ChipToolhelpper.QueryCMDMapper.REMOVE_KEYSET: self.remove_keyset_passer,
             ChipToolhelpper.QueryCMDMapper.BIND_GROUP_KEYSET: self.bind_group_keyset_passer,
+            ChipToolhelpper.QueryCMDMapper.UNBIND_GROUP_KEYSET: self.unbind_group_keyset_passer,
             ChipToolhelpper.QueryCMDMapper.APPLY_KEYSET: self.apply_keyset_passer,
+            ChipToolhelpper.QueryCMDMapper.DENIED_KEYSET: self.denied_keyset_passer,
             ChipToolhelpper.QueryCMDMapper.APPLY_KEYSET_MAP: self.apply_keyset_map_passer,
             ChipToolhelpper.QueryCMDMapper.APPLY_GROUP: self.apply_group_passer,
+            ChipToolhelpper.QueryCMDMapper.DENIED_GROUP: self.denied_group_passer,
         }
         return cancat_dict[context_type](contain=kwargs["contain"])
 
     def handle_command(self, context_type: ChipToolhelpper.QueryCMDMapper, *args, **kwargs) -> None:
         command = self.command_passer(context_type, contain=kwargs)
         status, result = self._CMDAccess.send_command(command)
         return status, result
@@ -600,68 +744,100 @@
             "nodeid": switch_node["nodeid"], "endpoint": switch_endpoint,
             "target_name": light_node["name"], "target_id": light_node["nodeid"],
             "endpoint": light_endpoint,
         }
         if (target_bind not in binding_list):
             binding_list.append(target_bind)
         else:
-            self._TyperExt.attach_log(
-                'binding already in binding list', self._TyperExt.Colors.GREEN)
+            self._logger.warning("binding already in binding list")
 
+        self._logger.info("Stage: Set Binding")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.SET_BINDING,
             binding_list=self.binding_json_passer(binding_list),
             nodeid=switch_node["nodeid"], endpoint=switch_endpoint
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: set switch binding failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("set switch binding failed")
 
         binding = self._ChipToolMgr.new_binding_profile(
             name=switch_node['name'], fabric=switch_node['fabric'],
             nodeid=switch_node['nodeid'], endpoint=switch_endpoint,
             target_name=light_node['name'], target_id=light_node['nodeid'],
             target_endpoint=light_endpoint
         )
         self._ChipToolMgr.apply_binding_profile(binding)
-        self._TyperExt.attach_log('Success: Execute command',
-                                  self._TyperExt.Colors.GREEN)
+        self._logger.info("Success: Execute command")
 
     def gen_group(self, group_name):
         self._ChipToolMgr.clear_failed_data()
         group = self._ChipToolMgr.new_group_profile(name=group_name)
+
+        self._logger.info("Stage: Create Group")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.CREATE_GROUP,
             name=group.name, group_id=group.group_id)
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Create Group failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Create Group failed")
 
+        self._logger.info("Stage: Create Keyset")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.CREATE_KEYSET,
             group_keyset_id=group.group_keyset_id, groupKeySecurityPolicy=0,
             epochStartTime0=2220000, epochKey0=group.epochkey0
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Create GroupKeySet failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Create GroupKeySet failed")
 
+        self._logger.info("Stage: Bind Keyset")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.BIND_GROUP_KEYSET,
             group_id=group.group_id, group_keyset_id=group.group_keyset_id
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Bind Group-Keyset failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Bind Group-Keyset failed")
+        self._logger.info("The group " + str(group_name) + " success created")
+        self._logger.info("Success: Execute command")
+
+    def del_group(self, group_name):
+        self._ChipToolMgr.clear_failed_data()
+        group = self._ChipToolMgr.get_group('name', group_name)
+        self._ChipToolMgr.delete_group(group_name)
+        self._logger.info(json.dumps(group))
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.UNBIND_GROUP_KEYSET,
+            group_id=group['group_id'], group_keyset_id=group['group_keyset_id'])
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Unbind Group failed")
 
-        self._TyperExt.attach_log(f"The group {str(group_name)} success created",
-                                  self._TyperExt.Colors.GREEN)
-        self._TyperExt.attach_log('Success: Execute command',
-                                  self._TyperExt.Colors.GREEN)
+        # status, result = self.handle_command(
+        #     ChipToolhelpper.QueryCMDMapper.REMOVE_KEYSET,
+        #     group_keyset_id=group['group_keyset_id'])
+        # if not (status == 0):
+        #     self._logger.error("Remove Keyset failed")
 
-    def add_group(self, group_name, target_type, target_name, target_endpoint):
+        self._logger.info("Stage: Remove Group")
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.REMOVE_GROUP,
+            group_id=group['group_id'])
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Remove Group failed")
+        self._logger.info("The group " + str(group_name) + " success remove")
+        self._logger.info("Success: Execute command")
+
+    def join_group(self, group_name, target_name, target_endpoint):
         self._ChipToolMgr.clear_failed_data()
-        target_type = target_type.upper()
         target_node = self._ChipToolMgr.get_profile(target_name)
+        target_type = target_node['devicetype'].upper()
         group = self._ChipToolMgr.get_group("name", group_name)
 
         group_mapper = self._ChipToolMgr.new_group_mapper_profile(
             name=group['name'], group_id=group['group_id'],
             target_id=target_node['nodeid'], target_name=target_name,
             target_type=target_type, target_endpoint=target_endpoint,
             status="Init"
@@ -671,134 +847,259 @@
 
         GKS = self.GroupKeySet(
             groupKeySetID=group['group_id'], groupKeySecurityPolicy=0,
             epochKey0=group['epochkey0'], epochStartTime0=2220000,
             epochKey1=group['epochkey1'], epochStartTime1=2220001,
             epochKey2=group['epochkey2'], epochStartTime2=2220002,
         )
-        self._TyperExt.attach_log('Execute: APPLY_KEYSET',
-                                  self._TyperExt.Colors.BRIGHT_CYAN)
+
+        self._logger.info("Stage: Apply Keyset")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.APPLY_KEYSET,
             group_key_set=json.dumps(dataclasses.asdict(GKS)),
             target_nodeid=target_node['nodeid'], target_endpoint="0"
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: APPLY_KEYSET failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("APPLY_KEYSET failed")
 
-        self._TyperExt.attach_log('Execute: APPLY_KEYSET_MAP',
-                                  self._TyperExt.Colors.BRIGHT_CYAN)
+        self._logger.info("Stage: Apply Keyset Map")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.APPLY_KEYSET_MAP,
             group_key_map_list=self.keyset_map_json_passer(
                 target_node["nodeid"], target_node["fabric"]),
             target_nodeid=target_node["nodeid"], target_endpoint="0"
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: APPLY_KEYSET_MAP failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("APPLY_KEYSET_MAP failed")
 
-        self._TyperExt.attach_log('Execute: APPLY_GROUP',
-                                  self._TyperExt.Colors.BRIGHT_CYAN)
+        self._logger.info("Stage: Apply Group")
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.APPLY_GROUP,
             groupId=group['group_id'], group_name=group['name'],
             target_nodeid=target_node['nodeid'], target_endpoint=target_endpoint
         )
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: APPLY_GROUP failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("APPLY_GROUP failed")
 
-        self._TyperExt.attach_log(target_type.upper(),
-                                  self._TyperExt.Colors.BRIGHT_CYAN)
+        self._logger.info("Stage: Setup Device Setting")
+        self._logger.info(target_type.upper())
         if target_type == "LIGHT":
-            self._TyperExt.attach_log('Execute: LIGHT ACL',
-                                      self._TyperExt.Colors.BRIGHT_CYAN)
             group["nodeid"] = group['group_id']
-            self._ChipToolLightMgr.set_group_acl(target_node, group)
+            self._ChipToolLightMgr.bind_group_acl(target_node, group)
         elif target_type == "SWITCH":
-            self._TyperExt.attach_log('Execute: SWITCH Group binding',
-                                      self._TyperExt.Colors.BRIGHT_CYAN)
             group_binding_list = self.group_binding_json_passer(
                 target_node["nodeid"], group['group_id'])
             status, result = self.handle_command(
                 ChipToolhelpper.QueryCMDMapper.SET_BINDING,
                 binding_list=group_binding_list,
                 nodeid=target_node["nodeid"], endpoint=target_endpoint
             )
             if not (status == 0):
-                self._TyperExt.raise_error(
-                    1, 'Failed: SWITCH srt binding failed')
+                self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+                self._logger.error("SWITCH srt binding failed")
 
         group_mapper.status = "Success"
         self._ChipToolMgr.update_group_profile(group_mapper)
-        self._TyperExt.attach_log(f"The group {str(group_name)} success add",
-                                  self._TyperExt.Colors.GREEN)
-        self._TyperExt.attach_log('Success: Execute command',
-                                  self._TyperExt.Colors.GREEN)
+        self._logger.info("The group " + str(group_name) + " uccess join")
+        self._logger.info("Success: Execute command")
+
+    def leave_group(self, group_name, target_name, target_endpoint):
+        self._ChipToolMgr.clear_failed_data()
+        target_node = self._ChipToolMgr.get_profile(target_name)
+        target_type = target_node['devicetype'].upper()
+        group_list = self._ChipToolMgr.get_group_mapper("name", group_name)
+        group = {}
+        for item in group_list:
+            if (item["target_name"] == target_name):
+                group = item
+                break
+        if not group:
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Device name not found in group")
+        self._ChipToolMgr.delete_group_mapper(
+            name=group['name'], nodeid=target_node['nodeid'], endpoint=target_endpoint)
+
+        self._logger.info("Stage: Clear Device Binding")
+        self._logger.info(target_type)
+        if target_type == "LIGHT":
+            group["nodeid"] = group['group_id']
+            self._ChipToolLightMgr.unbind_group_acl(target_node, group)
+        elif target_type == "SWITCH":
+            group_binding_list = self.group_binding_json_passer(
+                target_node["nodeid"], group['group_id'])
+            status, result = self.handle_command(
+                ChipToolhelpper.QueryCMDMapper.SET_BINDING,
+                binding_list=group_binding_list,
+                nodeid=target_node["nodeid"], endpoint=target_endpoint
+            )
+            if not (status == 0):
+                self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+                self._logger.error("SWITCH binding failed")
+
+        self._logger.info("Stage: Clear KEYSET Binding")
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.DENIED_KEYSET,
+            group_keyset_id=group['group_id'],
+            target_nodeid=target_node['nodeid'], target_endpoint="0"
+        )
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("DENIED_KEYSET failed")
+
+        self._logger.info("Stage: Clear KEYSET MAP")
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.DENIED_KEYSET_MAP,
+            group_key_map_list=self.keyset_map_json_passer(
+                target_node["nodeid"], target_node["fabric"]),
+            target_nodeid=target_node["nodeid"], target_endpoint="0"
+        )
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("DENIED_KEYSET_MAP failed")
+
+        self._logger.info("Stage: Clear Group")
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.DENIED_GROUP,
+            groupId=group['group_id'], target_nodeid=target_node['nodeid'],
+            target_endpoint=target_endpoint
+        )
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("DENIED_GROUP failed")
+
+        self._logger.info("The group " + str(group_name) + " success leave")
+        self._logger.info("Success: Execute command")
 
 
 class ChipToolConnectMgr:
     def __init__(self) -> None:
-        self._TyperExt = TyperExt()
         self._CMDAccess = CMDAccess()
         self._ChipToolMgr = ChipToolMgr()
+        self._DBHandler = DatabaseHandler()
+        self._OTBRMgr = OTBRMgr()
+        self._logger = get_logger("CMD")
+
+    def connect_passer(self, *args, **kwargs) -> None:
+        return ChipToolhelpper.CMDList.CONNECT_THEAD.value + [
+            str(kwargs["contain"]["nodeid"]),
+            "hex:"+kwargs["contain"]["otbr_hex"],
+            str(kwargs["contain"]["pincode"]),
+            str(kwargs["contain"]["discriminator"]),
+            "--ble-adapter",
+            str(kwargs["contain"]["ble_adapter"])
+        ]
+
+    def disconnect_passer(self, *args, **kwargs) -> None:
+        return ChipToolhelpper.CMDList.DISCONNECT_THEAD.value + [
+            str(kwargs["contain"]["nodeid"])
+        ]
+
+    def reset_matter_passer(self, *args, **kwargs) -> None:
+        self._logger.info(json.dumps(
+            ChipToolhelpper.CMDList.RESET_MATTER.value))
+        return ChipToolhelpper.CMDList.RESET_MATTER.value
+
+    def disable_srp_passer(self, *args, **kwargs) -> None:
+        return OTBRhelpper.CMDList.DISABLE_SRP.value
+
+    def enable_srp_passer(self, *args, **kwargs) -> None:
+        return OTBRhelpper.CMDList.ENABLE_SRP.value
 
     def command_passer(self, context_type, *args, **kwargs) -> None:
-        if context_type == ChipToolhelpper.QueryCMDMapper.CONN_THREAD:
-            return ChipToolhelpper.CMDList.CONNECT_THEAD.value + [
-                str(kwargs["contain"]["nodeid"]),
-                "hex:"+kwargs["contain"]["otbr_hex"],
-                str(kwargs["contain"]["pincode"]),
-                str(kwargs["contain"]["discriminator"]),
-                "--ble-adapter",
-                str(kwargs["contain"]["ble_adapter"])
-            ]
-        else:
-            return
+        cancat_dict = {
+            ChipToolhelpper.QueryCMDMapper.CONN_THREAD: self.connect_passer,
+            ChipToolhelpper.QueryCMDMapper.DISCONN_THREAD: self.disconnect_passer,
+            ChipToolhelpper.QueryCMDMapper.RESET_MATTER: self.reset_matter_passer,
+            OTBRhelpper.QueryCMDMapper.DISABLE_SRP: self.disable_srp_passer,
+            OTBRhelpper.QueryCMDMapper.ENABLE_SRP: self.enable_srp_passer,
+        }
+        return cancat_dict[context_type](contain=kwargs["contain"])
 
-    def handle_command(self, context_type: ChipToolhelpper.CMDList, *args, **kwargs) -> None:
-        kwargs["otbr_hex"] = self._ChipToolMgr.get_thread_network()
+    def handle_command(self, context_type, *args, **kwargs) -> None:
         command = self.command_passer(context_type, contain=kwargs)
-        self._TyperExt.attach_log(str(json.dumps(command)),
-                                  self._TyperExt.Colors.GREEN)
         status, result = self._CMDAccess.send_command(command)
         return status, result
 
     def connect(self, name, devicetype, pincode, discriminator, ble_adapter):
         self._ChipToolMgr.clear_failed_data()
+        self._logger.info("Stage: Get Thread Network")
+        otbr_hex = self._ChipToolMgr.get_thread_network()
+
+        self._logger.info("Stage: Start Connection")
         node = self._ChipToolMgr.new_node_profile(
             name=name, devicetype=devicetype)
         node.status = "Panding"
         self._ChipToolMgr.update_profile(node)
         status, result = self.handle_command(
             ChipToolhelpper.QueryCMDMapper.CONN_THREAD,
             nodeid=node.nodeid, pincode=pincode,
-            discriminator=discriminator, ble_adapter=ble_adapter)
+            discriminator=discriminator, otbr_hex=otbr_hex,
+            ble_adapter=ble_adapter)
         if not (status == 0):
-            self._TyperExt.raise_error(1, 'Failed: Connect failed')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Connect failed")
 
         fabric_index = -1
         for row in result:
             match = re.search(r'FabricIndex (\d+)', row)
             if match:
                 fabric_index = match.group(1)
                 if (fabric_index):
-                    # self._TyperExt.attach_log("FabricIndex " + str(fabric_index),
-                    #                           self._TyperExt.Colors.BRIGHT_YELLOW)
                     break
         if (fabric_index == -1):
-            self._TyperExt.raise_error(1, 'Failed: Connected Fabric not found')
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error("Connected Fabric not found")
 
         node.status = "Connected"
         node.fabric = fabric_index
         self._ChipToolMgr.update_profile(node)
 
+        self._logger.info("Stage: Setup ACL")
         acl = self._ChipToolMgr.new_acl_profile(name=node.name, fabric=fabric_index,
                                                 nodeid=node.nodeid, target_name="Admin",
                                                 target_id=112233, privilege=5,
                                                 auto_mode=2)
         self._ChipToolMgr.apply_acl_profile(acl=acl)
+        self._logger.info("The node name: " + node.name +
+                          " already connnected")
+        self._logger.info("Success: Execute command")
+
+    def disconnect(self, name):
+        self._ChipToolMgr.clear_failed_data()
+        node = self._ChipToolMgr.get_profile(name)
+
+        self._logger.info("Stage: Clear Profile")
+        self._ChipToolMgr.clear_profile(node)
 
-        self._TyperExt.attach_log("The node name: " + node.name +
-                                  " already connnected",
-                                  self._TyperExt.Colors.GREEN)
-        self._TyperExt.attach_log('Success: Execute command',
-                                  self._TyperExt.Colors.GREEN)
+        self._logger.info("Stage: Start Disconnect")
+        status, result = self.handle_command(
+            ChipToolhelpper.QueryCMDMapper.DISCONN_THREAD,
+            nodeid=node['nodeid'])
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error('Disconnect failed')
+
+    def reset(self):
+        self._DBHandler.init_database()
+        self._logger.info("Stage: Clear Profile")
+        for filePath in glob.glob('/tmp/chip_*'):
+            try:
+                os.remove(filePath)
+            except:
+                self._logger.error("Error while deleting file")
+
+        self._logger.info("Stage: Restart SRP")
+        status, result = self.handle_command(
+            OTBRhelpper.QueryCMDMapper.DISABLE_SRP)
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error('DISABLE_SRP')
+
+        time.sleep(3)
+        status, result = self.handle_command(
+            OTBRhelpper.QueryCMDMapper.ENABLE_SRP)
+        if not (status == 0):
+            self._logger.info("Execute time: " + str(stop_timmer("CMD")))
+            self._logger.error('ENABLE_SRP')
```

## matter_tool/api/OTBRMgr.py

```diff
@@ -1,18 +1,19 @@
 from .struct import OTBRData as OTBRDhelpper
 from ..extlib.CMDAccess.CMDAccess import CMDAccess
 from ..extlib.TyperExt.TyperExt import TyperExt
+from ..extlib.MgmtExt.log import get_logger
 
 
 class OTBRMgr:
 
     def __init__(self) -> None:
         self._CMDAccess = CMDAccess()
         self._TyperExt = TyperExt()
-        pass
+        self._logger = get_logger("APP")
 
     def pass_hex(self, context):
         rsp = context[0].split('\r\n')[0]
         return rsp
 
     def pass_data(self, context):
         check_list = [
@@ -40,18 +41,17 @@
         CMDList.OT_DATA_HEX.name: pass_hex,
         CMDList.OT_DATA.name: pass_data,
         CMDList.OT_STATE.name: pass_state,
     }
 
     def data_passer(self, ContextType: OTBRDhelpper.CMDList, context: str) -> None:
         if not OTBRDhelpper.check_command_exists(ContextType.value):
-            self._TyperExt.raise_error(1, 'Command not exists')
+            self._logger.error("Command not exists")
         rsp = self.PasserMapper[ContextType.value](self, context)
         return rsp
 
     def handle_command(self, ContextType: OTBRDhelpper.CMDList) -> None:
         resbin = self._CMDAccess.handle_OT_CMD(ContextType)
         result = self.data_passer(ContextType, resbin)
-        self._TyperExt.attach_log(str(result), self._TyperExt.Colors.GREEN)
-        self._TyperExt.attach_log('Success: Execute command',
-                                  self._TyperExt.Colors.GREEN)
+        self._logger.info(str(result))
+        self._logger.info("Success: Execute command")
         return result
```

## matter_tool/api/struct/ChipToolData.py

```diff
@@ -1,39 +1,57 @@
 from enum import Enum
 
 
 class CMDList(Enum):
-    LIGHT_ONOFF = ['chip-tool', 'onoff']
-    LEVEL_CTL = ['chip-tool', 'levelcontrol', 'move-to-level-with-on-off']
     CONNECT_THEAD = ['chip-tool', 'pairing', 'ble-thread']
+    DISCONNECT_THEAD = ['chip-tool', 'pairing', 'unpair']
+    RESET_MATTER = ['sudo', 'rm', '/tmp/chip_*']
     SET_ACL = ['chip-tool', 'accesscontrol', 'write', 'acl']
     WRITE_BINDING = ['chip-tool', 'binding', 'write', 'binding']
     CREATE_GROUP = ['chip-tool', 'groupsettings', 'add-group']
+    REMOVE_GROUP = ['chip-tool', 'groupsettings', 'remove-group']
     CREATE_KEYSET = ['chip-tool', 'groupsettings', 'add-keysets']
+    REMOVE_KEYSET = ['chip-tool', 'groupsettings', 'remove-keyset']
     BIND_GROUP_KEYSET = ['chip-tool', 'groupsettings', 'bind-keyset']
+    UNBIND_GROUP_KEYSET = ['chip-tool', 'groupsettings', 'unbind-keyset']
     APPLY_KEYSET = ['chip-tool', 'groupkeymanagement', 'key-set-write']
+    DENIED_KEYSET = ['chip-tool', 'groupkeymanagement', 'key-set-remove']
     APPLY_KEYSET_MAP = ['chip-tool',
                         'groupkeymanagement', 'write', 'group-key-map']
+    DENIED_KEYSET_MAP = ['chip-tool',
+                         'groupkeymanagement', 'write', 'group-key-map']
     APPLY_GROUP = ['chip-tool', 'groups', 'add-group']
+    DENIED_GROUP = ['chip-tool', 'groups', 'remove-group']
+    LIGHT_ONOFF = ['chip-tool', 'onoff']
+    LIGHT_GROUP_ONOFF = ['chip-tool', 'onoff', '0xffffffffffff']
+    LEVEL_CTL = ['chip-tool', 'levelcontrol', 'move-to-level-with-on-off']
     CHECK_COMMAND_SUCCESS = 'echo $?'
 
 
 class QueryCMDMapper(Enum):
-    LIGHT_ONOFF = CMDList.LIGHT_ONOFF.name
-    LEVEL_CONTROL = CMDList.LEVEL_CTL.name
     CONN_THREAD = CMDList.CONNECT_THEAD.name
+    DISCONN_THREAD = CMDList.DISCONNECT_THEAD.name
+    RESET_MATTER = CMDList.RESET_MATTER.name
     ACCESS_CONTROL = CMDList.SET_ACL.name
     SET_BINDING = CMDList.WRITE_BINDING.name
     CREATE_GROUP = CMDList.CREATE_GROUP.name
+    REMOVE_GROUP = CMDList.REMOVE_GROUP.name
     CREATE_KEYSET = CMDList.CREATE_KEYSET.name
+    REMOVE_KEYSET = CMDList.REMOVE_KEYSET.name
     BIND_GROUP_KEYSET = CMDList.BIND_GROUP_KEYSET.name
+    UNBIND_GROUP_KEYSET = CMDList.UNBIND_GROUP_KEYSET.name
     APPLY_KEYSET = CMDList.APPLY_KEYSET.name
+    DENIED_KEYSET = CMDList.DENIED_KEYSET.name
     APPLY_KEYSET_MAP = CMDList.APPLY_KEYSET_MAP.name
+    DENIED_KEYSET_MAP = CMDList.DENIED_KEYSET_MAP.name
+    LIGHT_ONOFF = CMDList.LIGHT_ONOFF.name
+    LIGHT_GROUP_ONOFF = CMDList.LIGHT_GROUP_ONOFF.name
+    LEVEL_CONTROL = CMDList.LEVEL_CTL.name
     APPLY_GROUP = CMDList.APPLY_GROUP.name
-
+    DENIED_GROUP = CMDList.DENIED_GROUP.name
     CHECK_STATE = CMDList.CHECK_COMMAND_SUCCESS.name
 
 
 def check_query_exists(query: str):
     return True if any(x for x in QueryCMDMapper if x.name == query) else False
```

## matter_tool/api/struct/OTBRData.py

```diff
@@ -1,20 +1,24 @@
 from enum import Enum
 
 
 class CMDList(Enum):
     OT_DATA_HEX = ['sudo', 'ot-ctl', 'dataset', 'active', '-x']
     OT_DATA = ['sudo', 'ot-ctl', 'dataset', 'active']
     OT_STATE = ['sudo', 'ot-ctl', 'state']
+    DISABLE_SRP = ['sudo', 'ot-ctl', 'srp', 'server', 'disable']
+    ENABLE_SRP = ['sudo', 'ot-ctl', 'srp', 'server', 'enable']
 
 
 class QueryCMDMapper(Enum):
     HEX = CMDList.OT_DATA_HEX.name
     DATA = CMDList.OT_DATA.name
     STATE = CMDList.OT_STATE.name
+    DISABLE_SRP = CMDList.DISABLE_SRP.name
+    ENABLE_SRP = CMDList.ENABLE_SRP.name
 
 
 def check_query_exists(query: str):
     return True if any(x for x in QueryCMDMapper if x.name == query) else False
 
 
 def check_command_exists(query: str):
```

## matter_tool/extlib/CMDAccess/CMDAccess.py

```diff
@@ -1,32 +1,32 @@
 import subprocess
 import typer
 from ..TyperExt.TyperExt import TyperExt
 from ...api.struct import OTBRData as OTBRHelpper
+from ...extlib.MgmtExt.log import get_logger
 
 
 class CMDAccess:
 
     def __init__(self) -> None:
-        self._TyperExt = TyperExt()
-        pass
+        self._logger = get_logger("CMD")
 
     def send_command(self, command_list: list):
         try:
             cmd_handle = subprocess.Popen(
                 command_list, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
             rsp = []
 
             for line in cmd_handle.stdout:
                 rsp.append(line.decode())
-                typer.secho(line.decode(), nl=False, fg=typer.colors.RESET)
+                self._logger.debug(line.decode().replace("\n", ""))
             status = cmd_handle.wait()
         except Exception as e:
-            self._TyperExt.raise_error(1, str(e))
+            self._logger.error(str(e))
         return status, rsp
 
-    def handle_OT_CMD(self, command: OTBRHelpper.QueryCMDMapper, *args, **kwargs):  # , *args, **kwargs
+    def handle_OT_CMD(self, command: OTBRHelpper.QueryCMDMapper, *args, **kwargs):
         if not (OTBRHelpper.check_query_exists(command.name)):
-            self._TyperExt.raise_error(1, 'command not found ' + str(command))
+            self._logger.error('command not found ' + str(command))
         prefix = OTBRHelpper.get_query_prefix(command.name)
         status, rsp = self.send_command(prefix)
         return rsp
```

## matter_tool/extlib/TyperExt/TyperExt.py

```diff
@@ -33,13 +33,7 @@
         raise typer.Exit(error)
 
     def attach_log(self, msg: str, color: Colors):
         if self.check_colors_exists(color.name):
             typer.secho(f'{msg}', fg=color.value)
         else:
             self.raise_error("UnSupport Color Type")
-
-    # def attach_log(self, tag, msg, color):
-    #     if self.check_colors_exists(color.name):
-    #         typer.secho(f'[{tag}]: {msg}', fg=color)
-    #     else:
-    #         self.raise_error("UnSupport Color Type")
```

## matter_tool/module/data/Database.py

```diff
@@ -4,18 +4,17 @@
 import configparser
 import json
 import dataclasses
 from pathlib import Path
 from typing import Any, Dict, List, NamedTuple
 from ...error import DB_WRITE_ERROR, SUCCESS
 from ...extlib.TyperExt.TyperExt import TyperExt
+from ...extlib.MgmtExt.log import get_logger
 
-DEFAULT_DB_FILE_PATH = Path.home().joinpath(
-    "." + Path.home().stem + "_EZMash.json"
-)
+DEFAULT_DB_FILE_PATH = Path.home().joinpath(".cpc_cli.json")
 
 
 class EnhancedJSONEncoder(json.JSONEncoder):
     def default(self, o):
         if dataclasses.is_dataclass(o):
             return dataclasses.asdict(o)
         return super().default(o)
@@ -25,15 +24,15 @@
     todo_list: List[Dict[str, Any]]
     error: int
 
 
 class DatabaseHandler:
     def __init__(self, db_path: Path = DEFAULT_DB_FILE_PATH) -> None:
         self._db_path = db_path
-        self._TyperExt = TyperExt()
+        self._logger = get_logger("DM")
 
     def init_database(self):
         """Create the to-do database."""
         empty_data = {}
         with self._db_path.open("w") as db:
             db.write(json.dumps(empty_data))  # Empty to-do list
 
@@ -45,33 +44,25 @@
     def read_matter_cluster(self, group, cluster):
         profile = {}
         try:
             with self._db_path.open("r") as db:
                 profile = json.load(db)
         except FileNotFoundError:
             self.init_database()
-        # self._TyperExt.attach_log("======= read_matter_cluster =======",
-        #                           self._TyperExt.Colors.WHITE)
-        # self._TyperExt.attach_log(json.dumps(profile),
-        #                           self._TyperExt.Colors.GREEN)
         self.check_exist_or_create(profile, group, {})
         self.check_exist_or_create(profile[group], cluster, [])
         return profile
 
     def read_matter_config_cluster(self):
         profile = {}
         try:
             with self._db_path.open("r") as db:
                 profile = json.load(db)
         except FileNotFoundError:
             self.init_database()
-        # self._TyperExt.attach_log("======= read_matter_config_cluster =======",
-        #                           self._TyperExt.Colors.WHITE)
-        # self._TyperExt.attach_log(json.dumps(profile),
-        #                           self._TyperExt.Colors.GREEN)
         group = "matter"
         cluster = "config"
         content = {"max_nodeid": 0, "max_groupid": 0}
         self.check_exist_or_create(profile, group, {})
         self.check_exist_or_create(profile[group], cluster, content)
         return profile
 
@@ -93,61 +84,41 @@
                 continue
             target_list.append(node)
             break
         return target_list
 
     def write_matter_profile(self, group, cluster, data) -> DBResponse:
         profile = self.read_matter_cluster(group, cluster)
+        self._logger.debug(json.dumps((group, cluster)))
+        self._logger.debug(json.dumps(dataclasses.asdict(data)))
         if (dataclasses.asdict(data) not in profile[group][cluster]):
             profile[group][cluster].append(dataclasses.asdict(data))
             with self._db_path.open("w") as db:
                 db.write(json.dumps(profile))
-        self.read_matter_cluster(group, cluster)  # for testing
         return DBResponse(profile, SUCCESS)
 
     def modify_matter_profile(self, group, cluster, key, data) -> DBResponse:
         profile = self.read_matter_cluster(group, cluster)
         data = dataclasses.asdict(data)
-        # self._TyperExt.attach_log(json.dumps(
-        #     (group, cluster)), self._TyperExt.Colors.BRIGHT_MAGENTA)
-        # self._TyperExt.attach_log(json.dumps(
-        #     data), self._TyperExt.Colors.BRIGHT_MAGENTA)
+        self._logger.debug(json.dumps((group, cluster)))
+        self._logger.debug(json.dumps(data))
         for idx in range(0, len(profile[group][cluster])):
             if (profile[group][cluster][idx][key] == data[key]):
                 profile[group][cluster][idx] = data
                 with self._db_path.open("w") as db:
                     db.write(json.dumps(profile))
-                self.read_matter_cluster(group, cluster)  # for testing
                 return DBResponse(profile, SUCCESS)
         return DBResponse(profile, DB_WRITE_ERROR)
 
     def update_matter_profile(self, group, cluster, data) -> DBResponse:
         profile = self.read_matter_cluster(group, cluster)
         profile[group][cluster] = data
         with self._db_path.open("w") as db:
             db.write(json.dumps(profile))
-        self.read_matter_cluster(group, cluster)  # for testing
         return DBResponse(profile, SUCCESS)
 
     def write_matter_config_profile(self, config):
         profile = self.read_matter_config_cluster()
         profile['matter']['config'] = config
         with self._db_path.open("w") as db:
             db.write(json.dumps(profile))
-        self.read_matter_config_cluster()  # for testing
         return DBResponse(profile, SUCCESS)
-
-
-def get_database_path(config_file: Path) -> Path:
-    """Return the current path to the to-do database."""
-    config_parser = configparser.ConfigParser()
-    config_parser.read(config_file)
-    return Path(config_parser["General"]["database"])
-
-
-def init_database(db_path: Path) -> int:
-    """Create the to-do database."""
-    try:
-        db_path.write_text("[]")  # Empty to-do list
-        return SUCCESS
-    except OSError:
-        return DB_WRITE_ERROR
```

## matter_tool/module/data/MatterDM.py

```diff
@@ -1,11 +1,12 @@
 from pathlib import Path
 from ...error import DB_WRITE_ERROR
 from .Database import DatabaseHandler
 from ...extlib.TyperExt.TyperExt import TyperExt
+from ...extlib.MgmtExt.log import get_logger
 from dataclasses import dataclass
 
 from .Database import DEFAULT_DB_FILE_PATH
 import json
 import secrets
 from enum import Enum
 
@@ -67,15 +68,15 @@
     class DeviceType(Enum):
         UNKNOW = 0
         LIGHT = 1
         SWITCH = 2
 
     def __init__(self, db_path: Path = DEFAULT_DB_FILE_PATH) -> None:
         self._db = DatabaseHandler(db_path)
-        self._TyperExt = TyperExt()
+        self._logger = get_logger("DM")
         self.nodeid_list = []
         self.name_list = []
         self.groupid_list = []
         self.group_name_list = []
         self.group_keyset_id = []
 
     def check_node_name_exist(self, name):
@@ -103,120 +104,114 @@
         for idx in range(1, 10001):
             if idx not in self.group_keyset_id:
                 id = idx
                 break
         return id
 
     def update_check_list(self):
-        # self._TyperExt.attach_log(
-        #     "+++ node +++", self._TyperExt.Colors.BRIGHT_MAGENTA)  # for test
+        self._logger.debug("+++ node +++")
         self.nodeid_list = []
         self.name_list = []
         for group, cluster in [("matter", "node"), ("matter", "failed_node")]:
             read = self._db.read_matter_cluster(group, cluster)
             nodelist = read[group][cluster]
             for idx in range(0, len(nodelist)):
-                # self._TyperExt.attach_log(json.dumps(
-                #     nodelist[idx]), self._TyperExt.Colors.BRIGHT_MAGENTA)  # for test
+                self._logger.debug(json.dumps(nodelist[idx]))
                 self.nodeid_list.append(nodelist[idx]["nodeid"])
                 self.name_list.append(nodelist[idx]["name"])
 
-        # self._TyperExt.attach_log(
-        #     "+++ group +++", self._TyperExt.Colors.BRIGHT_MAGENTA)  # for test
+        self._logger.debug("+++ group +++")
         self.groupid_list = []
         self.group_name_list = []
         self.group_keyset_id = []
         for group, cluster in [("matter", "group")]:
             read = self._db.read_matter_cluster(group, cluster)
             nodelist = read[group][cluster]
             for idx in range(0, len(nodelist)):
-                # self._TyperExt.attach_log(json.dumps(
-                #     nodelist[idx]), self._TyperExt.Colors.BRIGHT_MAGENTA)  # for test
+                self._logger.debug(json.dumps(nodelist[idx]))
                 self.groupid_list.append(nodelist[idx]["group_id"])
                 self.group_name_list.append(nodelist[idx]["name"])
                 self.group_keyset_id.append(nodelist[idx]["group_keyset_id"])
 
     def add_node(self, node: MatterNode):
         read = self._db.write_matter_profile("matter", "node", node)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def add_acl(self, acl: MatterACL):
         read = self._db.write_matter_profile("matter", "acl", acl)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def add_binding(self, binding: MatterBinding):
         read = self._db.write_matter_profile("matter", "binding", binding)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def add_group(self, group: MatterGroup):
         read = self._db.write_matter_profile("matter", "group", group)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def add_group_mapper(self, group_mapper: MatterGroupMapper):
         read = self._db.write_matter_profile(
             "matter", "group_mapper", group_mapper)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def update_node(self, node: MatterNode):
         self.check_node_vailed(node)
         read = self._db.modify_matter_profile("matter", "node", "nodeid", node)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def update_group_mapper(self, group_mapper: MatterGroupMapper):
         self.check_group_mapper_vailed(group_mapper)
         read = self._db.modify_matter_profile(
             "matter", "group_mapper", "group_id", group_mapper)
         if read.error == DB_WRITE_ERROR:
-            self._TyperExt.raise_error(1, 'Failed: DB_WRITE_ERROR')
+            self._logger.error("DB_WRITE_ERROR")
             return read.error
 
     def check_node_vailed(self, node: MatterNode):
         self.update_check_list()
         if node.nodeid == -1:
-            self._TyperExt.raise_error(1, 'Failed: Invailed nodeid')
+            self._logger.error("Invailed nodeid")
         status = self.check_node_name_exist(node.name)
         if not (status == 1):
-            self._TyperExt.raise_error(1, 'Failed: Invailed device name')
-        # self._TyperExt.attach_log(
-        #     "node are vailed", self._TyperExt.Colors.GREEN)
+            self._logger.error("Invailed device name")
+        self._logger.debug("node are vailed")
 
     def check_group_mapper_vailed(self, group_mapper: MatterGroupMapper):
         self.update_check_list()
         if group_mapper.group_id == -1:
-            self._TyperExt.raise_error(1, 'Failed: Invailed group_id')
+            self._logger.error("Invailed Invailed group_id")
         status = self.check_group_mapper_name_exist(group_mapper.name)
         if not (status == 1):
-            self._TyperExt.raise_error(1, 'Failed: Invailed group name')
-        # self._TyperExt.attach_log(
-        #     "group are vailed", self._TyperExt.Colors.GREEN)
+            self._logger.error("Invailed Invailed group name")
+        self._logger.debug("group are vailed")
 
     def create_node(self, *args, **kwargs):
         node = self.MatterNode(
             name=kwargs['name'], devicetype=kwargs["devicetype"],
             nodeid=-1, status="Init", fabric=-1
         )
         self.update_check_list()
         status = self.check_node_name_exist(node.name)
         if status == 1:
-            self._TyperExt.raise_error(1, 'Failed: Invailed device name')
+            self._logger.error("Invailed device name")
         node.nodeid = self.generate_nodeid()
         if node.nodeid == -1:
-            self._TyperExt.raise_error(1, 'Failed: Invailed nodeid')
+            self._logger.error("Invailed nodeid")
         return node
 
     def create_acl(self, *args, **kwargs):
         acl = self.MatterACL(
             name=kwargs['name'], fabric=kwargs['fabric'], nodeid=kwargs['nodeid'],
             target_name=kwargs['target_name'], target_id=kwargs['target_id'],
             privilege=kwargs['privilege'], auto_mode=kwargs['auto_mode']
@@ -237,158 +232,146 @@
             epochkey0=secrets.token_bytes(16).hex(),
             epochkey1=secrets.token_bytes(16).hex(),
             epochkey2=secrets.token_bytes(16).hex(),
         )
         self.update_check_list()
         status = self.check_node_name_exist(group.name)
         if status == 1:
-            self._TyperExt.raise_error(1, 'Failed: Invailed group name')
+            self._logger.error("Invailed Invailed group name")
 
         group.group_id = self.generate_groupid()
         if group.group_id == -1:
-            self._TyperExt.raise_error(1, 'Failed: generate groupid failed')
+            self._logger.error("generate groupid failed")
 
         group.group_keyset_id = self.generate_group_keyset_id()
         if group.group_keyset_id == -1:
-            self._TyperExt.raise_error(
-                1, 'Failed: generate group_keyset_id failed')
+            self._logger.error("generate group_keyset_id failed")
         return group
 
     def create_group_mapper(self, *args, **kwargs):
         group_mapper = self.MatterGroupMapper(
             name=kwargs['name'], group_id=kwargs['group_id'],
             target_id=kwargs['target_id'], target_name=kwargs['target_name'],
             target_type=kwargs['target_type'], target_endpoint=kwargs['target_endpoint'],
             status=kwargs['status']
         )
         return group_mapper
 
     def get_fully_group_list(self):
         read = self._db.read_matter_cluster("matter", "group")
-        # self._TyperExt.attach_log(json.dumps(
-        #     group_list), self._TyperExt.Colors.GREEN)
         return read
 
     def get_group_list(self, key, data):
         read = self._db.read_matter_cluster("matter", "group")
         group_list = []
         for node in read["matter"]["group"]:
             if node[key] == data:
                 group_list.append(node)
-        # self._TyperExt.attach_log(json.dumps(
-        #     group_list), self._TyperExt.Colors.GREEN)
         return group_list
 
     def get_fully_acl_list(self):
         read = self._db.read_matter_cluster("matter", "acl")
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return read
 
     def get_acl_list(self, key, data):
         read = self._db.read_matter_cluster("matter", "acl")
         acl_list = []
         for node in read["matter"]["acl"]:
             if node[key] == data:
                 acl_list.append(node)
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return acl_list
 
     def get_node_list(self):
         read = self._db.read_matter_cluster("matter", "node")
-        # self._TyperExt.attach_log(json.dumps(
-        #     read), self._TyperExt.Colors.GREEN)
         return read
 
     def get_fully_binding_list(self):
         read = self._db.read_matter_cluster("matter", "binding")
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return read
 
     def get_binding_list(self, key, data):
         read = self._db.read_matter_cluster("matter", "binding")
         acl_list = []
         for node in read["matter"]["binding"]:
             if node[key] == data:
                 acl_list.append(node)
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return acl_list
 
     def get_fully_group_mapper_list(self):
         read = self._db.read_matter_cluster("matter", "group_mapper")
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return read
 
     def get_group_mapper_list(self, key, data):
         read = self._db.read_matter_cluster("matter", "group_mapper")
         acl_list = []
         for node in read["matter"]["group_mapper"]:
             if node[key] == data:
                 acl_list.append(node)
-        # self._TyperExt.attach_log(json.dumps(
-        #     acl_list), self._TyperExt.Colors.GREEN)
         return acl_list
 
     def get_match_group_list(self, key, data):
         group = self._db.read_match_matter_cluster(
             "matter", "group", key, data)
         if not group:
-            self._TyperExt.raise_error(1, 'Failed: group name not found')
-        # self._TyperExt.attach_log(
-        #     "Access group success", self._TyperExt.Colors.GREEN)
-        # self._TyperExt.attach_log(json.dumps(
-        #     group), self._TyperExt.Colors.GREEN)
+            self._logger.error("group name not found")
         return group
 
     def get_group(self, key, data):
         group = self._db.read_single_matter_cluster(
             "matter", "group", key, data)
         if not group:
-            self._TyperExt.raise_error(1, 'Failed: group name not found')
-        # self._TyperExt.attach_log(
-        #     "Access group success", self._TyperExt.Colors.GREEN)
-        # self._TyperExt.attach_log(json.dumps(
-        #     group), self._TyperExt.Colors.GREEN)
+            self._logger.error("group name not found")
         return group
 
     def get_node(self, key, data):
         node = self._db.read_single_matter_cluster(
             "matter", "node", key, data)
         if not node:
-            self._TyperExt.raise_error(1, 'Failed: node name not found')
-        # self._TyperExt.attach_log(
-        #     "Access node success", self._TyperExt.Colors.GREEN)
-        # self._TyperExt.attach_log(json.dumps(
-        #     node), self._TyperExt.Colors.GREEN)
+            self._logger.error("node name not found")
         return node
 
-    def clear_failed_node(self):
-        read = self._db.read_matter_cluster("matter", "node")
-        # self._TyperExt.attach_log(json.dumps(
-        #     read), self._TyperExt.Colors.GREEN)
+    def delete_match(self, cluster, key, data):
+        read = self._db.read_matter_cluster("matter", cluster)
+        self._logger.debug(json.dumps(read))
         remove_list = []
-        for idx in range(len(read["matter"]["node"])):
-            if (not read["matter"]["node"][idx]['status'] == "Connected"):
+        for idx in range(len(read["matter"][cluster])):
+            if (str(read["matter"][cluster][idx][key]) == str(data)):
                 remove_list.append(idx)
-        for ele in sorted(remove_list, reverse=True):
-            del read["matter"]["node"][ele]
+        for element in sorted(remove_list, reverse=True):
+            del read["matter"][cluster][element]
         self._db.update_matter_profile(
-            "matter", "node", read["matter"]["node"])
+            "matter", cluster, read["matter"][cluster])
         return read
 
-    def clear_failed_group_mapper(self):
-        read = self._db.read_matter_cluster("matter", "group_mapper")
-        # self._TyperExt.attach_log(json.dumps(
-        #     read), self._TyperExt.Colors.GREEN)
+    def delete_multi_match(self, cluster, compare_list):
+        read = self._db.read_matter_cluster("matter", cluster)
+        self._logger.debug(json.dumps(read))
+        remove_list = []
+        match_counter = 0
+        delete_count = 0
+        for idx in range(len(read["matter"][cluster])):
+            for key, data in compare_list.items():
+                if (str(read["matter"][cluster][idx][key]) == str(data)):
+                    match_counter += 1
+                    if (match_counter == len(compare_list)):
+                        delete_count += 1
+                        remove_list.append(idx)
+                else:
+                    match_counter = 0
+        for element in sorted(remove_list, reverse=True):
+            del read["matter"][cluster][element]
+        self._db.update_matter_profile(
+            "matter", cluster, read["matter"][cluster])
+        return delete_count
+
+    def delete_mismatch(self, cluster, key, data):
+        read = self._db.read_matter_cluster("matter", cluster)
+        self._logger.debug(json.dumps(read))
         remove_list = []
-        for idx in range(len(read["matter"]["group_mapper"])):
-            if (not read["matter"]["group_mapper"][idx]['status'] == "Success"):
+        for idx in range(len(read["matter"][cluster])):
+            if (not str(read["matter"][cluster][idx][key]) == str(data)):
                 remove_list.append(idx)
-        for ele in sorted(remove_list, reverse=True):
-            del read["matter"]["group_mapper"][ele]
+        for element in sorted(remove_list, reverse=True):
+            del read["matter"][cluster][element]
         self._db.update_matter_profile(
-            "matter", "group_mapper", read["matter"]["group_mapper"])
+            "matter", cluster, read["matter"][cluster])
         return read
```

## Comparing `rafaelmicro_matter_tool-0.0.0.dist-info/RECORD` & `rafaelmicro_matter_tool-0.0.1.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 matter_tool/__init__.py,sha256=vuGbSwFUBvRkHSxpBD9qhSZAkQytgrs5jHO6-o9Fi3g,418
 matter_tool/__main__.py,sha256=AOTaQPmDcDrCSOXqRpTamyOScW5YIIGpseBx6faH-YU,189
-matter_tool/cli.py,sha256=esAhrW7p8n1rSYDAoyyOZ9aApJoP9XxmpEkewGVNiCI,5579
+matter_tool/cli.py,sha256=L38RsN-gPK9PNFJ94uCtUE5EW7g6-ZFnUmTMBMEqmyE,10361
 matter_tool/error.py,sha256=iDpLk_Avwdh6_vDXRyF2of8lqF3TqpKDgWwIGu3wrZg,339
-matter_tool/api/ChipToolMgr.py,sha256=Xzp4IiA9bZAtOWvDadhjZeQfIorbKd80n4fHJtFb2Tw,35357
-matter_tool/api/OTBRMgr.py,sha256=kIouPOOP2MTmO-OdhbF8OBD56bOrU5mPGspn6C21l9s,2009
+matter_tool/api/ChipToolMgr.py,sha256=-6h_7uq4J4qValzCPgsQL-BbhsQ7W88fnmx86YKXyXs,47662
+matter_tool/api/OTBRMgr.py,sha256=HEbbHWKmnFtuqUmQBZ61RebbS6gT8dTlkjko3bsDq6Q,1962
 matter_tool/api/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-matter_tool/api/struct/ChipToolData.py,sha256=gQ4Dq8uS4j1m9RYRY3ZQUoYKiPC_mSUGrAKO6P_OcXU,1730
-matter_tool/api/struct/OTBRData.py,sha256=EuBImWv-T-G4OZWN3S82nwXXAFZXdrc5V0-A46uLJAc,658
+matter_tool/api/struct/ChipToolData.py,sha256=T0Cu6jimJDFrrCvY2ZQTtTnmKzEHKi-zUqkXON96YTY,2802
+matter_tool/api/struct/OTBRData.py,sha256=0OinkUVF7KJxOkZ2q6y08ZgoXSM-eyVd0F-vNQWFQpk,870
 matter_tool/api/struct/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 matter_tool/extlib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-matter_tool/extlib/CMDAccess/CMDAccess.py,sha256=ruyVlhIfdRLGnMFnLHYIF7h4EjeD3D0_vN35v3foHbE,1112
+matter_tool/extlib/CMDAccess/CMDAccess.py,sha256=l1nDkz0PCWyn1RqcM4YiBJm8fo7rxSoBcrpyTZKjKCs,1098
 matter_tool/extlib/CMDAccess/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 matter_tool/extlib/CMDAccess/struct/CMD_data.py,sha256=H6iZtdN_bAiJqtojbwSuKxmqF4N9NN4ODo-6uz7T7IU,619
 matter_tool/extlib/CMDAccess/struct/ChipToolData.py,sha256=H6iZtdN_bAiJqtojbwSuKxmqF4N9NN4ODo-6uz7T7IU,619
 matter_tool/extlib/CMDAccess/struct/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-matter_tool/extlib/TyperExt/TyperExt.py,sha256=gdb2Sid0AL0nOVf0GX-tyxNKxwj5ThEnf6UcZO37I7A,1337
+matter_tool/extlib/TyperExt/TyperExt.py,sha256=C35ZyWnMEKY_QyWN-q05D74dUv7E9xGupR8adlWxFaQ,1114
 matter_tool/extlib/TyperExt/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 matter_tool/module/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-matter_tool/module/data/Database.py,sha256=Ku65IO0eT3nm6t2sImL8PnfU3ewrAxMltxNX-d9_vb0,5769
-matter_tool/module/data/MatterDM.py,sha256=jkRY8UsM8ELnCbkkoH0fL_ffAI6u9e04khvdL8dg664,14917
+matter_tool/module/data/Database.py,sha256=NZL8k6d5oT5bD5qWmtkpTTe5hvO5LpQJ2lm3VvVcxX4,4536
+matter_tool/module/data/MatterDM.py,sha256=Rt6f0FanKrnGnJiUo3MwnfPlUaOOuEHmEZlaerC_3-g,13469
 matter_tool/module/data/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-rafaelmicro_matter_tool-0.0.0.dist-info/METADATA,sha256=YBmCiUinPlalIrxE8_nZZfp24ArHA04SdLLfG5TamcY,7199
-rafaelmicro_matter_tool-0.0.0.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-rafaelmicro_matter_tool-0.0.0.dist-info/entry_points.txt,sha256=efHmi8gFkQcErp66sU2GEusZuCrxBJGzi5kstSs1EMw,77
-rafaelmicro_matter_tool-0.0.0.dist-info/top_level.txt,sha256=8qnJ1GgCm-D7Agcc2F8NgAmAdt2Fhxni7yOUZAaQH6o,12
-rafaelmicro_matter_tool-0.0.0.dist-info/RECORD,,
+rafaelmicro_matter_tool-0.0.1.dist-info/METADATA,sha256=9QfRHEWbGOZI9d_tsIa2xuGLePn7FnRsCnlwwTWncOY,9761
+rafaelmicro_matter_tool-0.0.1.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+rafaelmicro_matter_tool-0.0.1.dist-info/entry_points.txt,sha256=efHmi8gFkQcErp66sU2GEusZuCrxBJGzi5kstSs1EMw,77
+rafaelmicro_matter_tool-0.0.1.dist-info/top_level.txt,sha256=8qnJ1GgCm-D7Agcc2F8NgAmAdt2Fhxni7yOUZAaQH6o,12
+rafaelmicro_matter_tool-0.0.1.dist-info/RECORD,,
```

