# Comparing `tmp/Supermarq-0.4.1-py3-none-any.whl.zip` & `tmp/Supermarq-0.4.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,36 +1,36 @@
-Zip file size: 36151 bytes, number of entries: 34
--rw-r--r--  2.0 unx      605 b- defN 23-Jun-30 22:00 supermarq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Jun-30 22:00 supermarq/_version.py
--rw-r--r--  2.0 unx      306 b- defN 23-Jun-30 22:00 supermarq/_version_test.py
--rw-r--r--  2.0 unx      855 b- defN 23-Jun-30 22:00 supermarq/benchmark.py
--rw-r--r--  2.0 unx     1065 b- defN 23-Jun-30 22:00 supermarq/benchmark_test.py
--rw-r--r--  2.0 unx     4712 b- defN 23-Jun-30 22:00 supermarq/converters.py
--rw-r--r--  2.0 unx      447 b- defN 23-Jun-30 22:00 supermarq/converters_test.py
--rw-r--r--  2.0 unx     3194 b- defN 23-Jun-30 22:00 supermarq/features.py
--rw-r--r--  2.0 unx     1459 b- defN 23-Jun-30 22:00 supermarq/features_test.py
--rw-r--r--  2.0 unx    13014 b- defN 23-Jun-30 22:00 supermarq/plotting.py
--rw-r--r--  2.0 unx     1053 b- defN 23-Jun-30 22:00 supermarq/plotting_test.py
--rw-r--r--  2.0 unx      847 b- defN 23-Jun-30 22:00 supermarq/simulation.py
--rw-r--r--  2.0 unx    12680 b- defN 23-Jun-30 22:00 supermarq/stabilizers.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-30 22:00 supermarq/benchmarks/__init__.py
--rw-r--r--  2.0 unx     3917 b- defN 23-Jun-30 22:00 supermarq/benchmarks/bit_code.py
--rw-r--r--  2.0 unx      561 b- defN 23-Jun-30 22:00 supermarq/benchmarks/bit_code_test.py
--rw-r--r--  2.0 unx     1863 b- defN 23-Jun-30 22:00 supermarq/benchmarks/ghz.py
--rw-r--r--  2.0 unx      310 b- defN 23-Jun-30 22:00 supermarq/benchmarks/ghz_test.py
--rw-r--r--  2.0 unx     4175 b- defN 23-Jun-30 22:00 supermarq/benchmarks/hamiltonian_simulation.py
--rw-r--r--  2.0 unx      596 b- defN 23-Jun-30 22:00 supermarq/benchmarks/hamiltonian_simulation_test.py
--rw-r--r--  2.0 unx     8677 b- defN 23-Jun-30 22:00 supermarq/benchmarks/mermin_bell.py
--rw-r--r--  2.0 unx      741 b- defN 23-Jun-30 22:00 supermarq/benchmarks/mermin_bell_test.py
--rw-r--r--  2.0 unx     4354 b- defN 23-Jun-30 22:00 supermarq/benchmarks/phase_code.py
--rw-r--r--  2.0 unx      577 b- defN 23-Jun-30 22:00 supermarq/benchmarks/phase_code_test.py
--rw-r--r--  2.0 unx     7420 b- defN 23-Jun-30 22:00 supermarq/benchmarks/qaoa_fermionic_swap_proxy.py
--rw-r--r--  2.0 unx      922 b- defN 23-Jun-30 22:00 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py
--rw-r--r--  2.0 unx     5799 b- defN 23-Jun-30 22:00 supermarq/benchmarks/qaoa_vanilla_proxy.py
--rw-r--r--  2.0 unx      588 b- defN 23-Jun-30 22:00 supermarq/benchmarks/qaoa_vanilla_proxy_test.py
--rw-r--r--  2.0 unx     7077 b- defN 23-Jun-30 22:00 supermarq/benchmarks/vqe_proxy.py
--rw-r--r--  2.0 unx      483 b- defN 23-Jun-30 22:00 supermarq/benchmarks/vqe_proxy_test.py
--rw-r--r--  2.0 unx     2223 b- defN 23-Jun-30 22:01 Supermarq-0.4.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-30 22:01 Supermarq-0.4.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Jun-30 22:01 Supermarq-0.4.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2977 b- defN 23-Jun-30 22:01 Supermarq-0.4.1.dist-info/RECORD
-34 files, 93621 bytes uncompressed, 31319 bytes compressed:  66.5%
+Zip file size: 36752 bytes, number of entries: 34
+-rw-r--r--  2.0 unx      605 b- defN 23-Jul-06 15:28 supermarq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jul-06 15:28 supermarq/_version.py
+-rw-r--r--  2.0 unx      306 b- defN 23-Jul-06 15:28 supermarq/_version_test.py
+-rw-r--r--  2.0 unx      962 b- defN 23-Jul-06 15:28 supermarq/benchmark.py
+-rw-r--r--  2.0 unx     1065 b- defN 23-Jul-06 15:28 supermarq/benchmark_test.py
+-rw-r--r--  2.0 unx     4712 b- defN 23-Jul-06 15:28 supermarq/converters.py
+-rw-r--r--  2.0 unx      447 b- defN 23-Jul-06 15:28 supermarq/converters_test.py
+-rw-r--r--  2.0 unx     3194 b- defN 23-Jul-06 15:28 supermarq/features.py
+-rw-r--r--  2.0 unx     1459 b- defN 23-Jul-06 15:28 supermarq/features_test.py
+-rw-r--r--  2.0 unx    13156 b- defN 23-Jul-06 15:28 supermarq/plotting.py
+-rw-r--r--  2.0 unx     1053 b- defN 23-Jul-06 15:28 supermarq/plotting_test.py
+-rw-r--r--  2.0 unx      847 b- defN 23-Jul-06 15:28 supermarq/simulation.py
+-rw-r--r--  2.0 unx    12680 b- defN 23-Jul-06 15:28 supermarq/stabilizers.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-06 15:28 supermarq/benchmarks/__init__.py
+-rw-r--r--  2.0 unx     3917 b- defN 23-Jul-06 15:28 supermarq/benchmarks/bit_code.py
+-rw-r--r--  2.0 unx      561 b- defN 23-Jul-06 15:28 supermarq/benchmarks/bit_code_test.py
+-rw-r--r--  2.0 unx     1969 b- defN 23-Jul-06 15:28 supermarq/benchmarks/ghz.py
+-rw-r--r--  2.0 unx      310 b- defN 23-Jul-06 15:28 supermarq/benchmarks/ghz_test.py
+-rw-r--r--  2.0 unx     4319 b- defN 23-Jul-06 15:28 supermarq/benchmarks/hamiltonian_simulation.py
+-rw-r--r--  2.0 unx      596 b- defN 23-Jul-06 15:28 supermarq/benchmarks/hamiltonian_simulation_test.py
+-rw-r--r--  2.0 unx     9022 b- defN 23-Jul-06 15:28 supermarq/benchmarks/mermin_bell.py
+-rw-r--r--  2.0 unx      741 b- defN 23-Jul-06 15:28 supermarq/benchmarks/mermin_bell_test.py
+-rw-r--r--  2.0 unx     4354 b- defN 23-Jul-06 15:28 supermarq/benchmarks/phase_code.py
+-rw-r--r--  2.0 unx      577 b- defN 23-Jul-06 15:28 supermarq/benchmarks/phase_code_test.py
+-rw-r--r--  2.0 unx     7901 b- defN 23-Jul-06 15:28 supermarq/benchmarks/qaoa_fermionic_swap_proxy.py
+-rw-r--r--  2.0 unx      922 b- defN 23-Jul-06 15:28 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py
+-rw-r--r--  2.0 unx     6187 b- defN 23-Jul-06 15:28 supermarq/benchmarks/qaoa_vanilla_proxy.py
+-rw-r--r--  2.0 unx      588 b- defN 23-Jul-06 15:28 supermarq/benchmarks/qaoa_vanilla_proxy_test.py
+-rw-r--r--  2.0 unx     7539 b- defN 23-Jul-06 15:28 supermarq/benchmarks/vqe_proxy.py
+-rw-r--r--  2.0 unx      483 b- defN 23-Jul-06 15:28 supermarq/benchmarks/vqe_proxy_test.py
+-rw-r--r--  2.0 unx     2223 b- defN 23-Jul-06 15:28 Supermarq-0.4.2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-06 15:28 Supermarq-0.4.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-06 15:28 Supermarq-0.4.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2977 b- defN 23-Jul-06 15:28 Supermarq-0.4.2.dist-info/RECORD
+34 files, 95796 bytes uncompressed, 31920 bytes compressed:  66.7%
```

## zipnote {}

```diff
@@ -84,20 +84,20 @@
 
 Filename: supermarq/benchmarks/vqe_proxy.py
 Comment: 
 
 Filename: supermarq/benchmarks/vqe_proxy_test.py
 Comment: 
 
-Filename: Supermarq-0.4.1.dist-info/METADATA
+Filename: Supermarq-0.4.2.dist-info/METADATA
 Comment: 
 
-Filename: Supermarq-0.4.1.dist-info/WHEEL
+Filename: Supermarq-0.4.2.dist-info/WHEEL
 Comment: 
 
-Filename: Supermarq-0.4.1.dist-info/top_level.txt
+Filename: Supermarq-0.4.2.dist-info/top_level.txt
 Comment: 
 
-Filename: Supermarq-0.4.1.dist-info/RECORD
+Filename: Supermarq-0.4.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## supermarq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.4.1"
+__version__ = "0.4.2"
```

## supermarq/benchmark.py

```diff
@@ -18,8 +18,12 @@
 
     @abc.abstractmethod
     def circuit(self) -> Union[cirq.Circuit, Sequence[cirq.Circuit]]:
         """Returns the quantum circuit corresponding to the current benchmark parameters."""
 
     @abc.abstractmethod
     def score(self, counts: Any) -> float:
-        """Returns a normalized [0,1] score reflecting device performance."""
+        """Returns a normalized [0,1] score reflecting device performance.
+
+        Args:
+            counts: A dictionary containing the measurement counts from execution.
+        """
```

## supermarq/plotting.py

```diff
@@ -336,15 +336,20 @@
 
         Returns:
             A list of `matplotlib.patches.Polygon`.
         """
         return super().fill(closed=closed, *args, **kwargs)
 
     def plot(self, *args: Any, **kwargs: Any) -> None:
-        """Override plot so that line is closed by default"""
+        """Overrides plot so that line is closed by default.
+
+        Args:
+            args: Desired arguments for plotting.
+            kwargs: Other desired keyword arguments for plotting.
+        """
         lines = super().plot(*args, **kwargs)
         for line in lines:
             self._close_line(line)
 
     def _close_line(self, line: matplotlib.lines.Line2D) -> None:
         """A method to close the input line.
```

## supermarq/benchmarks/ghz.py

```diff
@@ -40,14 +40,17 @@
 
         The ideal results are 50% probabilty of measuring the all-zero state and 50% probability
         of measuring the all-one state.
 
         The formula for the Hellinger fidelity between two distributions p and q is given by
         $(\sum_i{p_i q_i})^2$.
 
+        Args:
+            counts: A dictionary containing the measurement counts from circuit execution.
+
         Returns:
             Hellinger fidelity as a float.
         """
         # Create an equal weighted distribution between the all-0 and all-1 states
         ideal_dist = {b * self.num_qubits: 0.5 for b in ["0", "1"]}
         total_shots = sum(counts.values())
         device_dist = {bitstr: count / total_shots for bitstr, count in counts.items()}
```

## supermarq/benchmarks/hamiltonian_simulation.py

```diff
@@ -37,14 +37,17 @@
 
         H(t) = - Jz * sum_{i=1}^{n-1}(sigma_{z}^{i} * sigma_{z}^{i+1})
                - e_ph * cos(w_ph * t) * sum_{i=1}^{n}(sigma_{x}^{i})
 
         where,
             w_ph: frequency of E" phonon in MoSe2.
             e_ph: strength of electron-phonon coupling.
+
+        Returns:
+            The circuit for Hamiltonian simulation.
         """
         hbar = 0.658212  # eV*fs
         jz = (
             hbar * np.pi / 4
         )  # eV, coupling coeff; Jz<0 is antiferromagnetic, Jz>0 is ferromagnetic
         freq = 0.0048  # 1/fs, frequency of MoSe2 phonon
 
@@ -92,14 +95,17 @@
         """Compute the average magnetization of the TFIM chain along the Z-axis
         for the experimental results and via noiseless simulation.
 
         Args:
             counts: Dictionary of the experimental results. The keys are bitstrings
                 represented the measured qubit state, and the values are the number
                 of times that state of observed.
+
+        Returns:
+            The Hamiltonian simulation benchmark score.
         """
         ideal_counts = supermarq.simulation.get_ideal_counts(self.circuit())
 
         total_shots = int(sum(counts.values()))
 
         mag_ideal = self._average_magnetization(ideal_counts, 1)
         mag_experimental = self._average_magnetization(counts, total_shots)
```

## supermarq/benchmarks/mermin_bell.py

```diff
@@ -5,32 +5,35 @@
 import sympy
 
 from supermarq import stabilizers
 from supermarq.benchmark import Benchmark
 
 
 class MerminBell(Benchmark):
-    """The Mermin-Bell benchmark is a test of a quantum computer's ability
-    to exploit purely quantum phenomemna such as superposition and entanglement.
-    It is based on the famous Bell-inequality tests of locality.
-
-    Performance is based on a QPU's ability to prepare a GHZ state and measure
+    """The Mermin-Bell benchmark is a test of a quantum computer's ability to exploit purely quantum
+    phenomemna such as superposition and entanglement. It is based on the famous Bell-inequality
+    tests of locality. Performance is based on a QPU's ability to prepare a GHZ state and measure
     the Mermin operator.
     """
 
     def __init__(self, num_qubits: int) -> None:
         self.num_qubits = num_qubits
         self.qubits = cirq.LineQubit.range(self.num_qubits)
 
         self.mermin_operator = self._mermin_operator(self.num_qubits)
         self.stabilizer, self.pauli_basis = stabilizers.construct_stabilizer(
             self.num_qubits, self.mermin_operator
         )
 
     def circuit(self) -> cirq.Circuit:
+        """The Mermin-Bell circuit, simultaneously measuring Mermin terms in a GHZ circuit.
+
+        Returns:
+            The Mermin-Bell `cirq.Circuit`.
+        """
 
         circuit = cirq.Circuit()
 
         # Create a GHZ state
         circuit.append(cirq.rx(-np.pi / 2).on(self.qubits[0]))
         for i in range(self.num_qubits - 1):
             circuit.append(cirq.CNOT(self.qubits[i], self.qubits[i + 1]))
@@ -40,15 +43,21 @@
         circuit.append(measurement_circuit.get_circuit())
 
         return circuit
 
     def score(self, counts: Dict[str, float]) -> float:
         """Compute the score for the N-qubit Mermin-Bell benchmark.
 
-        This function assumes the regular big endian ordering of bitstring results
+        This function assumes the regular big endian ordering of bitstring results.
+
+        Args:
+            counts: A dictionary containing the measurement counts from circuit execution.
+
+        Returns:
+            The score for the Mermin-Bell benchmark score.
         """
 
         # Store the conjugation rules for H, S, CX, CZ, SWAP in dictionaries. The keys are
         # the pauli strings to be conjugated and the values are the resulting pauli strings
         # after conjugation.
         # The typing here was added to satisfy mypy. Declaring this dict without the explicit
         # typing gets created as Dict[EigenGate, Dict[str, str]], but iterating through a
```

## supermarq/benchmarks/qaoa_fermionic_swap_proxy.py

```diff
@@ -112,14 +112,22 @@
         expectation_value = 0.0
         for bitstring, probability in probabilities.items():
             expectation_value += probability * self._get_energy_for_bitstring(bitstring)
         return expectation_value
 
     def _get_opt_angles(self) -> Tuple[npt.NDArray[np.float_], float]:
         def f(params: npt.NDArray[np.float_]) -> float:
+            """The objective function to minimize.
+
+            Args:
+                params: The parameters at which to evaluate the objective.
+
+            Returns:
+                Evaluation of objective given parameters.
+            """
             gamma, beta = params
             circ = self._gen_swap_network(gamma, beta)
             # Reverse bitstring ordering due to SWAP network
             raw_probs = supermarq.simulation.get_ideal_counts(circ)
             probs = {bitstring[::-1]: probability for bitstring, probability in raw_probs.items()}
             h_expect = self._get_expectation_value_from_probs(probs)
 
@@ -143,24 +151,32 @@
 
     def circuit(self) -> cirq.Circuit:
         """Generate a QAOA circuit for the Sherrington-Kirkpatrick model.
 
         This particular benchmark utilizes a quantum circuit structure called
         the fermionic swap network. We restrict the depth of this proxy benchmark
         to p=1 to keep the classical simulation scalable.
+
+        Returns:
+            The S-K model QAOA `cirq.Circuit`.
         """
         gamma, beta = self.params
         return self._gen_swap_network(gamma, beta)
 
     def score(self, counts: Mapping[str, float]) -> float:
         """Compare the experimental output to the output of noiseless simulation.
 
-        The implementation here has exponential runtime and would not scale.
-        However, it could in principle be done efficiently via
-        https://arxiv.org/abs/1706.02998, so we're good.
+        The implementation here has exponential runtime and would not scale. However, it could in
+        principle be done efficiently via https://arxiv.org/abs/1706.02998, so we're good.
+
+        Args:
+            counts: A dictionary containing the measurement counts from circuit execution.
+
+        Returns:
+            The QAOA Fermionic SWAP proxy benchmark score.
         """
         # Reverse bitstring ordering due to SWAP network
         raw_probs = supermarq.simulation.get_ideal_counts(self.circuit())
         ideal_counts = {
             bitstring[::-1]: probability for bitstring, probability in raw_probs.items()
         }
         total_shots = sum(counts.values())
```

## supermarq/benchmarks/qaoa_vanilla_proxy.py

```diff
@@ -90,14 +90,21 @@
         expectation_value = 0.0
         for bitstring, probability in probabilities.items():
             expectation_value += probability * self._get_energy_for_bitstring(bitstring)
         return expectation_value
 
     def _get_opt_angles(self) -> Tuple[npt.NDArray[np.float_], float]:
         def f(params: npt.NDArray[np.float_]) -> float:
+            """The objective function to minimize.
+
+            Args:
+
+            Returns:
+                Evaluation of objective given parameters.
+            """
             gamma, beta = params
             circ = self._gen_ansatz(gamma, beta)
             probs = supermarq.simulation.get_ideal_counts(circ)
             objective_value = self._get_expectation_value_from_probs(probs)
 
             return -objective_value  # because we are minimizing instead of maximizing
 
@@ -116,27 +123,35 @@
                 best_params = params
                 best_cost = cost
         return best_params
 
     def circuit(self) -> cirq.Circuit:
         """Generate a QAOA circuit for the Sherrington-Kirkpatrick model.
 
-        The ansatz structure is given by the form of the Hamiltonian and requires
-        interactions between every pair of qubits. We restrict the depth of this proxy
-        benchmark to p=1 to keep the classical simulation scalable.
+        The ansatz structure is given by the form of the Hamiltonian and requires interactions
+        between every pair of qubits. We restrict the depth of this proxy benchmark to p=1 to keep
+        the classical simulation scalable.
+
+        Returns:
+            The S-K model QAOA circuit.
         """
         gamma, beta = self.params
         return self._gen_ansatz(gamma, beta)
 
     def score(self, counts: Mapping[str, float]) -> float:
         """Compare the experimental output to the output of noiseless simulation.
 
-        The implementation here has exponential runtime and would not scale.
-        However, it could in principle be done efficiently via
-        https://arxiv.org/abs/1706.02998, so we're good.
+        The implementation here has exponential runtime and would not scale. However, it could in
+        principle be done efficiently via https://arxiv.org/abs/1706.02998, so we're good.
+
+        Args:
+            counts: A dictionary containing measurement counts from circuit execution.
+
+        Returns:
+            The QAOA Vanilla proxy benchmark score.
         """
         ideal_counts = supermarq.simulation.get_ideal_counts(self.circuit())
         total_shots = sum(counts.values())
         experimental_counts = {k: v / total_shots for k, v in counts.items()}
 
         ideal_value = self._get_expectation_value_from_probs(ideal_counts)
         experimental_value = self._get_expectation_value_from_probs(experimental_counts)
```

## supermarq/benchmarks/vqe_proxy.py

```diff
@@ -114,14 +114,22 @@
             bit_list_z.append(bitstr[0] + bitstr[-1])  # Add the wrap-around term manually
             avg_energy += self._calc(bit_list_z, bitstr, probs_z)
 
         return avg_energy
 
     def _get_opt_angles(self) -> Tuple[npt.NDArray[np.float_], float]:
         def f(params: npt.NDArray[np.float_]) -> float:
+            """The objective function to minimize.
+
+            Args:
+                params: The parameters at which to evaluate the objective.
+
+            Returns:
+                Evaluation of objective given parameters.
+            """
             z_circuit, x_circuit = self._gen_ansatz(params)
             z_probs = supermarq.simulation.get_ideal_counts(z_circuit)
             x_probs = supermarq.simulation.get_ideal_counts(x_circuit)
             energy = self._get_expectation_value_from_probs(z_probs, x_probs)
 
             return -energy  # because we are minimizing instead of maximizing
 
@@ -138,26 +146,34 @@
         """
         params, _ = self._get_opt_angles()
         return params
 
     def circuit(self) -> List[cirq.Circuit]:
         """Construct a parameterized ansatz.
 
-        Returns a list of circuits: the ansatz measured in the Z basis, and the
-        ansatz measured in the X basis. The counts obtained from evaluated these
-        two circuits should be passed to `score` in the same order they are
-        returned here.
+        The counts obtained from evaluating these two circuits should be passed to `score` in the
+        same order they are returned here.
+
+        Returns:
+            A list of circuits for the VQE benchmark: the ansatz measured in the Z basis, and the
+            ansatz measured in the X basis.
         """
         return self._gen_ansatz(self._params)
 
     def score(self, counts: List[Dict[str, float]]) -> float:
-        """Compare the average energy measured by the experiments to the ideal
-        value obtained via noiseless simulation. In principle the ideal value
-        can be obtained through efficient classical means since the 1D TFIM
-        is analytically solvable.
+        """Compare the average energy measured by the experiments to the ideal value.
+
+        The ideal value is obtained via noiseless simulation. In principle the ideal value can be
+        obtained through efficient classical means since the 1D TFIM is analytically solvable.
+
+        Args:
+            counts: A dictionary containing the measurement counts from circuit execution.
+
+        Returns:
+            The VQE proxy benchmark score.
         """
         counts_z, counts_x = counts
         shots_z = sum(counts_z.values())
         probs_z = {bitstr: count / shots_z for bitstr, count in counts_z.items()}
         shots_x = sum(counts_x.values())
         probs_x = {bitstr: count / shots_x for bitstr, count in counts_x.items()}
         experimental_expectation = self._get_expectation_value_from_probs(probs_z, probs_x)
```

## Comparing `Supermarq-0.4.1.dist-info/METADATA` & `Supermarq-0.4.2.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: Supermarq
-Version: 0.4.1
+Version: 0.4.2
 Summary: Supermarq is a scalable, application-centric quantum benchmarking suite.
 Home-page: https://github.com/Infleqtion/client-superstaq
 Author: Superstaq development team
 Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
-Requires-Dist: cirq-superstaq (~=0.4.1)
+Requires-Dist: cirq-superstaq (~=0.4.2)
 Requires-Dist: matplotlib (<=3.5.2)
-Requires-Dist: qiskit-superstaq (~=0.4.1)
+Requires-Dist: qiskit-superstaq (~=0.4.2)
 Requires-Dist: scikit-learn (>=1.0)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.4.1) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.4.2) ; extra == 'dev'
 
 <p align="center">
   <img width="300" src="../docs/source/_static/logos/supermarq-logo.webp">
 </p>
 
 ---
 ![Continuous Integration](https://github.com/Infleqtion/client-superstaq/actions/workflows/ci.yml/badge.svg)
```

## Comparing `Supermarq-0.4.1.dist-info/RECORD` & `Supermarq-0.4.2.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 supermarq/__init__.py,sha256=8Ag_aSTxuwp0Hnx0aJMR97BP7a5ryVmqI-XvnH1nViU,605
-supermarq/_version.py,sha256=pMtTmSUht-XtbR_7Doz6bsQqopJJd8rZ8I8zy2HwwoA,22
+supermarq/_version.py,sha256=6hfVa12Q-nXyUEXr6SyKpqPEDJW6vlRHyPxlA27PfTs,22
 supermarq/_version_test.py,sha256=ZRN6-Z2m4tiFuE3b_HOsLDmRgqOINZWPwwROhln9jDI,306
-supermarq/benchmark.py,sha256=oSlDlUpt0dRasHLR_zPXnD3uiDXr9-eaZZ15pYhQpVQ,855
+supermarq/benchmark.py,sha256=1IeGYpu15_qPBcc5X9qS785UjgJoI-Y98GBop7Ini9A,962
 supermarq/benchmark_test.py,sha256=Wn5L1DJleTVtq3eKxLggo98bGv2tw2g9oNZg7gaeVPM,1065
 supermarq/converters.py,sha256=VyTEyqQbNtEhfhRGvrLhTOHDIMs0L7u85FT4GjFR9_c,4712
 supermarq/converters_test.py,sha256=2crWi67JRazjs_WE8OCoiNqD7t7up9htT0UPYzCxLW8,447
 supermarq/features.py,sha256=dl5_t40EjHwhCGwbZsEyuLbKqtr8HKLbK6JgXAXaXQU,3194
 supermarq/features_test.py,sha256=hNO3yZk8N7WqMVEMrhNMMaq2SyKdf97vzz0anj_VJM8,1459
-supermarq/plotting.py,sha256=LYUMgH8aeUb6hmrP5q6ygRtv5l4IfnRI4tButQzdoGI,13014
+supermarq/plotting.py,sha256=pEHIYm8gvR1x9vBx1nD50jrwlrQEZA6ZieO7J8Ep3Co,13156
 supermarq/plotting_test.py,sha256=XZ4VpNWjymmUA0nOMmLDL9H4wNnVlu8NssvrbBmjysM,1053
 supermarq/simulation.py,sha256=MBKFbUQfHajYARI3-1syH83cbwTGpxi1ZyIZ-Y2bh1A,847
 supermarq/stabilizers.py,sha256=ugh9slYRhoQK_1YtXDVG7Dk5inV2MyOAwDvC3zopVvo,12680
 supermarq/benchmarks/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 supermarq/benchmarks/bit_code.py,sha256=BheUnM1Zc8SJFmRcm2QhQ8XNOw9lW4Yfg0muw2UO_zg,3917
 supermarq/benchmarks/bit_code_test.py,sha256=4FwwGsTcHlWOwnJ4MzwNthEwqIzLOvBgO09UhrU2qIM,561
-supermarq/benchmarks/ghz.py,sha256=zQMcMRGrRVDc3Vpo5d8jejfZ0OATvxDc1V03bJ1Cbwo,1863
+supermarq/benchmarks/ghz.py,sha256=ilCWO2_xFkzqNaPQRFlqonQcKqH7QoAQ2fyGDogTa7U,1969
 supermarq/benchmarks/ghz_test.py,sha256=z0QyTeIUOxlTBfUJ-w-5vuieCjoDR-m7sEuj9TYs_7A,310
-supermarq/benchmarks/hamiltonian_simulation.py,sha256=G27vCa3fWM9sp0XJRrGivWmrZrYYClVAEcyzqILr2PM,4175
+supermarq/benchmarks/hamiltonian_simulation.py,sha256=MM8iTUuWuARiPAMfGlSYRrcC3QFh5-xrePZDvCTDpE0,4319
 supermarq/benchmarks/hamiltonian_simulation_test.py,sha256=fRSzBp1u3Ehwh_s8xT67E9DU6-_C2tqGZSIpCZ-rxns,596
-supermarq/benchmarks/mermin_bell.py,sha256=qlXrwepITCYxDEyGulBqMdRqQGRYGF90dHr0aqmtDoo,8677
+supermarq/benchmarks/mermin_bell.py,sha256=bjJRVDaw2xE98o4HENykI1p3axppcb_1XfgtrzpvzgI,9022
 supermarq/benchmarks/mermin_bell_test.py,sha256=xuBQYo5bUXi5Q0pEZjbSjrJwuKb0QJisRXZvimzbc1M,741
 supermarq/benchmarks/phase_code.py,sha256=UzdzoYzYcqeVUZ1TGVxvDzNZHSbmOMGlNhyorAnEwtg,4354
 supermarq/benchmarks/phase_code_test.py,sha256=GrBjJmBWpQgCpZPuLo-gpLFlmSedy6UmqOFT_m-B-yo,577
-supermarq/benchmarks/qaoa_fermionic_swap_proxy.py,sha256=kjxEkgycsrtpO6mukF6zC6dMVUXKkV40q4lH35JlZ70,7420
+supermarq/benchmarks/qaoa_fermionic_swap_proxy.py,sha256=mFv9QeAGT5o6DqiuGo7d10pEMTDJqcG9VilUhhxFYN4,7901
 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py,sha256=OFgOJOSzL6iBGVQj5CuBPb2t0dQnIp4eJui-fhifaZ4,922
-supermarq/benchmarks/qaoa_vanilla_proxy.py,sha256=_DzncYEVfTc1QzmKeN7pCUUDsMx9WjoBYJQBW60wUTI,5799
+supermarq/benchmarks/qaoa_vanilla_proxy.py,sha256=YP9Rf4Rk75wifKEzXHHvfG-1TVytbL1Qs7NHL6mWyMQ,6187
 supermarq/benchmarks/qaoa_vanilla_proxy_test.py,sha256=9uBqXMICByt50o-CzmxPvNaKnE1r2icHqlZa7DV9qbc,588
-supermarq/benchmarks/vqe_proxy.py,sha256=U1r-Fq17Jrt8VnxjAlVdwhD8QAZN93v5VBhW24od1n0,7077
+supermarq/benchmarks/vqe_proxy.py,sha256=BXlGdU2ADjdTdYKUbu3T5BKqfju00UkBfxxJhUNlHVw,7539
 supermarq/benchmarks/vqe_proxy_test.py,sha256=Tany-2cSDYTjHKWUZbhe0q5bdpJmJxf2UIMK7P14HC0,483
-Supermarq-0.4.1.dist-info/METADATA,sha256=ukqjjAts4voz0F0my-sYS6tOq3py8YFJ-iEmDtJgrxw,2223
-Supermarq-0.4.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-Supermarq-0.4.1.dist-info/top_level.txt,sha256=V8aTWpwY33e-w7kLvEOVE_4GqyxxOXu5XMWDjoauq54,10
-Supermarq-0.4.1.dist-info/RECORD,,
+Supermarq-0.4.2.dist-info/METADATA,sha256=PDodmGdDDUy-3yNqwXSwb-hKpWnvEfiLOBKKxsN_Qyw,2223
+Supermarq-0.4.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+Supermarq-0.4.2.dist-info/top_level.txt,sha256=V8aTWpwY33e-w7kLvEOVE_4GqyxxOXu5XMWDjoauq54,10
+Supermarq-0.4.2.dist-info/RECORD,,
```

