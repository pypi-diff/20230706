# Comparing `tmp/cirq_superstaq-0.4.1-py3-none-any.whl.zip` & `tmp/cirq_superstaq-0.4.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,27 @@
-Zip file size: 53287 bytes, number of entries: 23
--rw-r--r--  2.0 unx     2495 b- defN 23-Jun-30 22:00 cirq_superstaq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Jun-30 22:00 cirq_superstaq/_version.py
--rw-r--r--  2.0 unx      312 b- defN 23-Jun-30 22:00 cirq_superstaq/_version_test.py
--rw-r--r--  2.0 unx    12248 b- defN 23-Jun-30 22:00 cirq_superstaq/compiler_output.py
--rw-r--r--  2.0 unx    13843 b- defN 23-Jun-30 22:00 cirq_superstaq/compiler_output_test.py
--rw-r--r--  2.0 unx     9766 b- defN 23-Jun-30 22:00 cirq_superstaq/daily_integration_test.py
--rw-r--r--  2.0 unx     6815 b- defN 23-Jun-30 22:00 cirq_superstaq/job.py
--rw-r--r--  2.0 unx     6704 b- defN 23-Jun-30 22:00 cirq_superstaq/job_test.py
--rw-r--r--  2.0 unx       68 b- defN 23-Jun-30 22:00 cirq_superstaq/py.typed
--rw-r--r--  2.0 unx     3067 b- defN 23-Jun-30 22:00 cirq_superstaq/sampler.py
--rw-r--r--  2.0 unx     1430 b- defN 23-Jun-30 22:00 cirq_superstaq/serialization.py
--rw-r--r--  2.0 unx     1604 b- defN 23-Jun-30 22:00 cirq_superstaq/serialization_test.py
--rw-r--r--  2.0 unx    28607 b- defN 23-Jun-30 22:00 cirq_superstaq/service.py
--rw-r--r--  2.0 unx    23128 b- defN 23-Jun-30 22:00 cirq_superstaq/service_test.py
--rw-r--r--  2.0 unx     1297 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/__init__.py
--rw-r--r--  2.0 unx    33936 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qubit_gates.py
--rw-r--r--  2.0 unx    38578 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qubit_gates_test.py
--rw-r--r--  2.0 unx    19243 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qudit_gates.py
--rw-r--r--  2.0 unx    16989 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qudit_gates_test.py
--rw-r--r--  2.0 unx     2304 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1995 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/RECORD
-23 files, 224558 bytes uncompressed, 50039 bytes compressed:  77.7%
+Zip file size: 54675 bytes, number of entries: 25
+-rw-r--r--  2.0 unx     2525 b- defN 23-Jul-06 15:28 cirq_superstaq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jul-06 15:28 cirq_superstaq/_version.py
+-rw-r--r--  2.0 unx      312 b- defN 23-Jul-06 15:28 cirq_superstaq/_version_test.py
+-rw-r--r--  2.0 unx    12266 b- defN 23-Jul-06 15:28 cirq_superstaq/compiler_output.py
+-rw-r--r--  2.0 unx    13843 b- defN 23-Jul-06 15:28 cirq_superstaq/compiler_output_test.py
+-rw-r--r--  2.0 unx     9766 b- defN 23-Jul-06 15:28 cirq_superstaq/daily_integration_test.py
+-rw-r--r--  2.0 unx     6815 b- defN 23-Jul-06 15:28 cirq_superstaq/job.py
+-rw-r--r--  2.0 unx     6704 b- defN 23-Jul-06 15:28 cirq_superstaq/job_test.py
+-rw-r--r--  2.0 unx       68 b- defN 23-Jul-06 15:28 cirq_superstaq/py.typed
+-rw-r--r--  2.0 unx     3067 b- defN 23-Jul-06 15:28 cirq_superstaq/sampler.py
+-rw-r--r--  2.0 unx     1430 b- defN 23-Jul-06 15:28 cirq_superstaq/serialization.py
+-rw-r--r--  2.0 unx     1604 b- defN 23-Jul-06 15:28 cirq_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    28806 b- defN 23-Jul-06 15:28 cirq_superstaq/service.py
+-rw-r--r--  2.0 unx    22685 b- defN 23-Jul-06 15:28 cirq_superstaq/service_test.py
+-rw-r--r--  2.0 unx      743 b- defN 23-Jul-06 15:28 cirq_superstaq/validation.py
+-rw-r--r--  2.0 unx      789 b- defN 23-Jul-06 15:28 cirq_superstaq/validation_test.py
+-rw-r--r--  2.0 unx     1297 b- defN 23-Jul-06 15:28 cirq_superstaq/ops/__init__.py
+-rw-r--r--  2.0 unx    35310 b- defN 23-Jul-06 15:28 cirq_superstaq/ops/qubit_gates.py
+-rw-r--r--  2.0 unx    38578 b- defN 23-Jul-06 15:28 cirq_superstaq/ops/qubit_gates_test.py
+-rw-r--r--  2.0 unx    20064 b- defN 23-Jul-06 15:28 cirq_superstaq/ops/qudit_gates.py
+-rw-r--r--  2.0 unx    16989 b- defN 23-Jul-06 15:28 cirq_superstaq/ops/qudit_gates_test.py
+-rw-r--r--  2.0 unx     2304 b- defN 23-Jul-06 15:28 cirq_superstaq-0.4.2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-06 15:28 cirq_superstaq-0.4.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-Jul-06 15:28 cirq_superstaq-0.4.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2168 b- defN 23-Jul-06 15:28 cirq_superstaq-0.4.2.dist-info/RECORD
+25 files, 228262 bytes uncompressed, 51153 bytes compressed:  77.6%
```

## zipnote {}

```diff
@@ -36,14 +36,20 @@
 
 Filename: cirq_superstaq/service.py
 Comment: 
 
 Filename: cirq_superstaq/service_test.py
 Comment: 
 
+Filename: cirq_superstaq/validation.py
+Comment: 
+
+Filename: cirq_superstaq/validation_test.py
+Comment: 
+
 Filename: cirq_superstaq/ops/__init__.py
 Comment: 
 
 Filename: cirq_superstaq/ops/qubit_gates.py
 Comment: 
 
 Filename: cirq_superstaq/ops/qubit_gates_test.py
@@ -51,20 +57,20 @@
 
 Filename: cirq_superstaq/ops/qudit_gates.py
 Comment: 
 
 Filename: cirq_superstaq/ops/qudit_gates_test.py
 Comment: 
 
-Filename: cirq_superstaq-0.4.1.dist-info/METADATA
+Filename: cirq_superstaq-0.4.2.dist-info/METADATA
 Comment: 
 
-Filename: cirq_superstaq-0.4.1.dist-info/WHEEL
+Filename: cirq_superstaq-0.4.2.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_superstaq-0.4.1.dist-info/top_level.txt
+Filename: cirq_superstaq-0.4.2.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_superstaq-0.4.1.dist-info/RECORD
+Filename: cirq_superstaq-0.4.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_superstaq/__init__.py

```diff
@@ -8,15 +8,15 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from cirq_superstaq import compiler_output
+from cirq_superstaq import compiler_output, validation
 from cirq_superstaq._version import __version__
 from cirq_superstaq.compiler_output import active_qubit_indices, measured_qubit_indices
 from cirq_superstaq.job import Job
 from cirq_superstaq.ops import (
     AQTICCX,
     AQTITOFFOLI,
     BSWAP,
@@ -103,8 +103,9 @@
     "deserialize_circuits",
     "ops",
     "parallel_gates_operation",
     "qubit_subspace_op",
     "qudit_swap_op",
     "serialization",
     "serialize_circuits",
+    "validation",
 ]
```

## cirq_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.4.1"
+__version__ = "0.4.2"
```

## cirq_superstaq/compiler_output.py

```diff
@@ -37,15 +37,15 @@
     for op in circuit.all_operations():
         if not isinstance(op.gate, css.Barrier):
             all_qubits.update(op.qubits)
 
     qubit_indices: List[int] = []
     for q in sorted(all_qubits):
         if not isinstance(q, (cirq.LineQubit, cirq.LineQid)):
-            raise ValueError("Qubit indices can only be determined for line qubits")
+            raise ValueError("Qubit indices can only be determined for line qubits.")
         qubit_indices.append(int(q))
 
     return qubit_indices
 
 
 def measured_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
     """Returns the indices of the measured qubits in a quantum circuit.
@@ -101,15 +101,15 @@
             circuits: A list (of at most 2 dimensions) containing `cirq.Circuit` objects.
             final_logical_to_physicals: Post-compilation mapping of logical qubits to physical
                 qubits.
             pulse_sequences: The qiskit pulse schedules for the compiled circuit(s).
             seq: A `qtrl` pulse sequence, if `qtrl` is available locally.
             jaqal_programs: The Jaqal program (resp. programs) as a string (resp. list of
                 strings).
-            pulse_lists: Either 3 or 4 dimensional lists of pulse cycles.
+            pulse_lists: Optional list of pulse cycles if `qtrl` is available locally.
         """
         if isinstance(circuits, cirq.Circuit):
             self.circuit = circuits
             self.final_logical_to_physical = final_logical_to_physicals
             self.pulse_list = pulse_lists
             self.pulse_sequence = pulse_sequences
             self.jaqal_program = jaqal_programs
@@ -220,20 +220,20 @@
 
     seq = None
     pulse_lists = None
 
     if "state_jp" not in json_dict:
         warnings.warn(
             "This output only contains compiled circuits (using a default AQT gate set). To "
-            "get back the corresponding pulse sequence, you must first upload your qtrl configs "
+            "get back the corresponding pulse sequence, you must first upload your `qtrl` configs "
             "using `service.aqt_upload_configs`."
         )
     elif not importlib.util.find_spec("qtrl"):
         warnings.warn(
-            "This output only contains compiled circuits. The qtrl package must be installed in "
+            "This output only contains compiled circuits. The `qtrl` package must be installed in "
             "order to deserialize compiled pulse sequences."
         )
     else:  # pragma: no cover, b/c qtrl is not open source so it is not in cirq-superstaq reqs
 
         def _sequencer_from_state(state: Dict[str, Any]) -> qtrl.sequencer.Sequence:
             seq = qtrl.sequencer.Sequence(n_elements=1)
             seq.__setstate__(state)
```

## cirq_superstaq/service.py

```diff
@@ -95,38 +95,14 @@
             combine_key_names: np.array(samples),
         },
     )
 
     return result
 
 
-def _validate_cirq_circuits(circuits: object) -> None:
-    """Validates that the input is either a single `cirq.Circuit` or a list of `cirq.Circuit`
-    instances.
-
-    Args:
-        circuits: The circuit(s) to run.
-
-    Raises:
-        ValueError: If the input is not a `cirq.Circuit` or a list of `cirq.Circuit` instances.
-    """
-
-    if not (
-        isinstance(circuits, cirq.Circuit)
-        or (
-            isinstance(circuits, Sequence)
-            and all(isinstance(circuit, cirq.Circuit) for circuit in circuits)
-        )
-    ):
-        raise ValueError(
-            "Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
-            "sequence of `cirq.Circuit` instances."
-        )
-
-
 class Service(user_config.UserConfig):
     """A class to access Superstaq's API.
 
     To access the API, this class requires a remote host url and an API key. These can be
     specified in the constructor via the parameters `remote_host` and `api_key`. Alternatively
     these can be specified by setting the environment variables `SUPERSTAQ_REMOTE_HOST` and
     `SUPERSTAQ_API_KEY`, or setting an API key in a configuration file.
@@ -278,15 +254,15 @@
         Returns:
             A `css.Job` which can be queried for status or results.
 
         Raises:
             ValueError: If `circuit` is not a valid `cirq.Circuit` or has no measurements to sample.
             SuperstaqException: If there was an error accessing the API.
         """
-        _validate_cirq_circuits(circuit)
+        css.validation.validate_cirq_circuits(circuit)
         if not isinstance(circuit, cirq.Circuit):
             raise ValueError("This endpoint does not support the submission of multiple circuits.")
 
         if not circuit.has_measurements():
             # TODO: only raise if the run method actually requires samples (and not for e.g. a
             # statevector simulation)
             raise ValueError("Circuit has no measurements to sample.")
@@ -335,30 +311,34 @@
         """
         balance = self._client.get_balance()["balance"]
         if pretty_output:
             return f"${balance:,.2f}"
         return balance
 
     def get_targets(self) -> Dict[str, List[str]]:
-        """Get list of available targets."""
+        """Gets a list of available, unavailable, and retired targets.
+
+        Returns:
+            A list of Superstaq targets.
+        """
         return self._client.get_targets()["superstaq_targets"]
 
     def resource_estimate(
         self, circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]], target: Optional[str] = None
     ) -> Union[ResourceEstimate, List[ResourceEstimate]]:
         """Generates resource estimates for circuit(s).
 
         Args:
-            circuits:  The cirq circuit(s) to generate resource estimate.
+            circuits:  The circuit(s) to generate resource estimate.
             target: String of target representing target device.
 
         Returns:
             `ResourceEstimate`(s) containing resource costs (after compilation).
         """
-        _validate_cirq_circuits(circuits)
+        css.validation.validate_cirq_circuits(circuits)
         circuit_is_list = not isinstance(circuits, cirq.Circuit)
         serialized_circuit = css.serialization.serialize_circuits(circuits)
 
         target = self._resolve_target(target)
 
         request_json = {
             "cirq_circuits": serialized_circuit,
@@ -384,41 +364,42 @@
         target: str = "aqt_keysight_qpu",
         atol: Optional[float] = None,
         gate_defs: Optional[
             Mapping[str, Union[npt.NDArray[np.complex_], cirq.Gate, cirq.Operation, None]]
         ] = None,
         **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles and optimizes the given circuit(s) for the Advanced Quantum Testbed (AQT) at
-        Lawrence Berkeley National Laboratory using Equivalent Circuit Averaging (ECA).
+        """Compiles and optimizes the given circuit(s) for AQT using ECA.
 
-        See arxiv.org/pdf/2111.04572.pdf for a description of ECA.
+        The Advanced Quantum Testbed (AQT) is a superconducting transmon quantum computing testbed
+        at Lawrence Berkeley National Laboratory. See arxiv.org/pdf/2111.04572.pdf for a description
+        of Equivalent Circuit Averaging (ECA).
 
         Note:
             This method has been deprecated. Instead, use the `num_eca_circuits` argument of
             `aqt_compile()`.
 
         Args:
             circuits: The circuit(s) to compile.
             num_equivalent_circuits: Number of logically equivalent random circuits to generate for
                 each input circuit.
             random_seed: Optional seed for circuit randomizer.
             target: String of target AQT device.
             atol: An optional tolerance to use for approximate gate synthesis.
-            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+            gate_defs: An optional dictionary mapping names in `qtrl` configs to operations, where
                 each operation can be a unitary matrix, `cirq.Gate`, `cirq.Operation`, or None. More
                 specific associations take precedence, for example `{"SWAP": cirq.SQRT_ISWAP,
                 "SWAP/C5C4": cirq.SQRT_ISWAP_INV}` implies `SQRT_ISWAP` for all "SWAP" calibrations
                 except "SWAP/C5C4" (which will instead be mapped to a `SQRT_ISWAP_INV` gate on
                 qubits 4 and 5). Setting any calibration to None will disable that calibration.
             kwargs: Other desired aqt_compile_eca options.
 
         Returns:
             Object whose .circuits attribute is a list (or list of lists) of logically equivalent
-            circuits. If qtrl is installed, the object's .seq attribute is a qtrl Sequence object
+            circuits. If `qtrl` is installed, the object's .seq attribute is a qtrl Sequence object
             containing pulse sequences for each compiled circuit, and its .pulse_list(s) attribute
             contains the corresponding list(s) of cycles.
 
         Raises:
             ValueError: If `target` is not a valid AQT target.
         """
         warnings.warn(
@@ -463,37 +444,37 @@
         Args:
             circuits: The circuit(s) to compile.
             target: String of target AQT device.
             num_eca_circuits: Optional number of logically equivalent random circuits to generate
                 from each input circuit for Equivalent Circuit Averaging (ECA).
             random_seed: Optional seed used for approximate synthesis and ECA.
             atol: An optional tolerance to use for approximate gate synthesis.
-            gate_defs: An optional dictionary mapping names in qtrl configs to operations, where
+            gate_defs: An optional dictionary mapping names in `qtrl` configs to operations, where
                 each operation can be a unitary matrix, `cirq.Gate`, `cirq.Operation`, or None. More
                 specific associations take precedence, for example `{"SWAP": cirq.SQRT_ISWAP,
                 "SWAP/C5C4": cirq.SQRT_ISWAP_INV}` implies `SQRT_ISWAP` for all "SWAP" calibrations
                 except "SWAP/C5C4" (which will instead be mapped to a `SQRT_ISWAP_INV` gate on
                 qubits 4 and 5). Setting any calibration to None will disable that calibration.
             kwargs: Other desired compile options.
 
         Returns:
             Object whose .circuit(s) attribute contains the optimized circuits(s). Alternatively for
             ECA, an object whose .circuits attribute is a list (or list of lists) of logically
-            equivalent circuits. If qtrl is installed, the object's .seq attribute is a qtrl
+            equivalent circuits. If `qtrl` is installed, the object's .seq attribute is a qtrl
             Sequence object containing pulse sequences for each compiled circuit, and its
             .pulse_list(s) attribute contains the corresponding list(s) of cycles.
 
         Raises:
             ValueError: If `target` is not a valid AQT target.
         """
         target = self._resolve_target(target)
         if not target.startswith("aqt_"):
             raise ValueError(f"{target!r} is not a valid AQT target.")
 
-        _validate_cirq_circuits(circuits)
+        css.validation.validate_cirq_circuits(circuits)
         serialized_circuits = css.serialization.serialize_circuits(circuits)
         circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
         request_json = {
             "cirq_circuits": serialized_circuits,
             "target": target,
         }
@@ -563,15 +544,15 @@
         target = self._resolve_target(target)
         if not target.startswith("sandia_"):
             raise ValueError(f"{target!r} is not a valid Sandia target.")
 
         if base_entangling_gate not in ("xx", "zz"):
             raise ValueError("base_entangling_gate must be either 'xx' or 'zz'")
 
-        _validate_cirq_circuits(circuits)
+        css.validation.validate_cirq_circuits(circuits)
         serialized_circuits = css.serialization.serialize_circuits(circuits)
         circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
         options_dict = {
             "mirror_swaps": mirror_swaps,
             "base_entangling_gate": base_entangling_gate,
             **kwargs,
@@ -622,15 +603,15 @@
 
         Qiskit Terra must be installed to correctly deserialize pulse schedules for pulse-enabled
         targets.
 
         Args:
             circuits: The circuit(s) to compile.
             target: String of target IBMQ device.
-            kwargs: Other desired ibmq_compile options.
+            kwargs: Other desired `ibmq_compile` options.
 
         Returns:
             Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s), and whose
             .pulse_sequence(s) attribute contains the corresponding pulse schedule(s) (when
             available).
 
         Raises:
@@ -644,52 +625,67 @@
 
     def compile(
         self,
         circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
         target: str,
         **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
-        """Compiles the given circuit(s) to the target device.
+        """Compiles the given circuit(s) to the target device's native gateset.
 
         Args:
             circuits: The circuit(s) to compile.
             target: String of target device.
-            kwargs: Other desired compilation options.
+            kwargs: Other desired compile options.
 
         Returns:
-            Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s).
+            A `CompilerOutput` object whose .circuit(s) attribute contains optimized compiled
+            circuit(s).
         """
-        _validate_cirq_circuits(circuits)
-        serialized_circuits = css.serialization.serialize_circuits(circuits)
-        circuits_is_list = not isinstance(circuits, cirq.Circuit)
 
         target = self._resolve_target(target)
 
+        if target.startswith("aqt_"):
+            return self.aqt_compile(circuits, **kwargs)
+        elif target.startswith("sandia_"):
+            return self.qscout_compile(circuits, **kwargs)
+
+        request_json = self._get_compile_request_json(circuits, target, **kwargs)
+        circuits_is_list = not isinstance(circuits, cirq.Circuit)
+        json_dict = self._client.compile(request_json)
+        return css.compiler_output.read_json(json_dict, circuits_is_list)
+
+    def _get_compile_request_json(
+        self,
+        circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]],
+        target: str,
+        **kwargs: Any,
+    ) -> Dict[str, str]:
+        """Helper method to compile json dictionary."""
+
+        css.validation.validate_cirq_circuits(circuits)
+        serialized_circuits = css.serialization.serialize_circuits(circuits)
         request_json = {
             "cirq_circuits": serialized_circuits,
             "target": target,
             "options": cirq.to_json(kwargs),
         }
-
-        json_dict = self._client.compile(request_json)
-
-        return css.compiler_output.read_json(json_dict, circuits_is_list)
+        return request_json
 
     def supercheq(
         self, files: List[List[int]], num_qubits: int, depth: int
     ) -> Tuple[List[cirq.Circuit], npt.NDArray[np.float_]]:
         """Returns the randomly generated circuits and the fidelity matrix for inputted files.
 
         Args:
             files: Input files from which to generate random circuits and fidelity matrix.
-            num_qubits: Number of qubits for the circuits.
-            depth: The circuit depth for Supercheq.
+            num_qubits: The number of qubits to use to generate random circuits.
+            depth: The depth of the random circuits to generate.
 
         Returns:
-            A tuple containing the circuits and fidelities.
+            A tuple containing the generated circuits and the fidelities for distinguishing files.
         """
 
         json_dict = self._client.supercheq(files, num_qubits, depth, "cirq_circuits")
         circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
         fidelities = gss.serialization.deserialize(json_dict["fidelities"])
         return circuits, fidelities
```

## cirq_superstaq/service_test.py

```diff
@@ -60,33 +60,14 @@
         cirq.measure(qubits[0], key="0"),
         cirq.measure(qubits[1], key="1"),
     )
     result = css.service.counts_to_results({"00": 50, "11": 50}, circuit, cirq.ParamResolver({}))
     assert result.histogram(key="01") == collections.Counter({0: 50, 3: 50})
 
 
-def test_validate_cirq_circuits() -> None:
-    qubits = [cirq.LineQubit(i) for i in range(2)]
-    circuit = cirq.Circuit(cirq.H(qubits[0]), cirq.CNOT(qubits[0], qubits[1]))
-
-    with pytest.raises(
-        ValueError,
-        match="Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
-        "sequence of `cirq.Circuit` instances.",
-    ):
-        css.service._validate_cirq_circuits("circuit_invalid")
-
-    with pytest.raises(
-        ValueError,
-        match="Invalid 'circuits' input. Must be a `cirq.Circuit` or a "
-        "sequence of `cirq.Circuit` instances.",
-    ):
-        css.service._validate_cirq_circuits([circuit, "circuit_invalid"])
-
-
 def test_service_resolve_target() -> None:
     service = css.Service(api_key="key", default_target="ss_bar_qpu")
     assert service._resolve_target("ss_foo_qpu") == "ss_foo_qpu"
     assert service._resolve_target(None) == "ss_bar_qpu"
 
     service = css.Service(api_key="key")
     assert service._resolve_target("ss_foo_qpu") == "ss_foo_qpu"
@@ -253,15 +234,15 @@
                 "d-wave_advantage-system4.1_qpu",
                 "d-wave_dw-2000q-6_qpu",
                 "aws_tn1_simulator",
                 "rigetti_aspen-9_qpu",
                 "d-wave_advantage-system1.1_qpu",
                 "ionq_ion_qpu",
             ],
-            "compile-only": ["aqt_keysight_qpu", "sandia_qscout_qpu"],
+            "compile-only": ["aqt_keysight_qpu", "aqt_zurich_qpu", "sandia_qscout_qpu"],
         }
     }
     mock_client.get_targets.return_value = targets
     service._client = mock_client
 
     assert service.get_targets() == targets["superstaq_targets"]
 
@@ -282,18 +263,22 @@
         "/aqt_compile",
         {
             "cirq_circuits": css.serialization.serialize_circuits(cirq.Circuit()),
             "target": "aqt_keysight_qpu",
             "options": '{\n  "test_options": "yes"\n}',
         },
     )
-    assert out.circuit == cirq.Circuit()
-    assert out.final_logical_to_physical == {}
-    assert not hasattr(out, "circuits") and not hasattr(out, "pulse_lists")
-    assert not hasattr(out, "final_logical_to_physicals")
+
+    alt_out = service.compile(cirq.Circuit(), target="aqt_keysight_qpu", test_options="yes")
+
+    for output in [out, alt_out]:
+        assert output.circuit == cirq.Circuit()
+        assert output.final_logical_to_physical == {}
+        assert not hasattr(output, "circuits") and not hasattr(output, "pulse_lists")
+        assert not hasattr(output, "final_logical_to_physicals")
 
     gate_defs = {
         "CZ3": css.CZ3,
         "CZ3/T5C4": None,
         "CS/simul": css.ParallelGates(cirq.CZ, cirq.CZ).on(*cirq.LineQubit.range(4, 8)),
         "CS2": cirq.unitary(cirq.CZ**0.49),
         "CS3": cirq.unitary(css.CZ3**0.5),
@@ -429,18 +414,23 @@
         "cirq_circuits": css.serialization.serialize_circuits(circuit),
         "final_logical_to_physicals": cirq.to_json([list(final_logical_to_physical.items())]),
         "jaqal_programs": [jaqal_program],
     }
 
     service = css.Service(api_key="key", remote_host="http://example.com")
     out = service.qscout_compile(circuit, test_options="yes")
+    alt_out = service.compile(circuit, target="sandia_qscout_qpu", test_options="yes")
     assert out.circuit == circuit
     assert out.final_logical_to_physical == final_logical_to_physical
     assert out.jaqal_program == jaqal_program
 
+    assert alt_out.circuit == circuit
+    assert alt_out.final_logical_to_physical == final_logical_to_physical
+    assert alt_out.jaqal_program == jaqal_program
+
     with pytest.raises(ValueError, match="'ss_example_qpu' is not a valid Sandia target."):
         service.qscout_compile(cirq.Circuit(), target="ss_example_qpu")
 
 
 @mock.patch("general_superstaq.superstaq_client._SuperstaqClient.qscout_compile")
 @pytest.mark.parametrize("mirror_swaps", (True, False))
 def test_qscout_compile_swap_mirror(
@@ -588,17 +578,11 @@
 
 @mock.patch.dict(os.environ, {"SUPERSTAQ_REMOTE_HOST": "http://example.com"})
 def test_service_remote_host_via_env() -> None:
     service = css.Service("tomyheart")
     assert service._client.remote_host == "http://example.com"
 
 
-@mock.patch.dict(os.environ, {"SUPERSTAQ_API_KEY": ""})
-def test_service_no_param_or_env_variable() -> None:
-    with pytest.raises(EnvironmentError):
-        _ = css.Service(remote_host="http://example.com")
-
-
 @mock.patch.dict(os.environ, clear=True)
 def test_service_no_url_default() -> None:
     service = css.Service("tomyheart")
     assert service._client.remote_host == gss.API_URL
```

## cirq_superstaq/ops/qubit_gates.py

```diff
@@ -7,15 +7,25 @@
 import numpy.typing as npt
 from cirq.ops.common_gates import _pi
 
 import cirq_superstaq as css
 
 
 def approx_eq_mod(a: cirq.TParamVal, b: cirq.TParamVal, period: float, atol: float = 1e-8) -> bool:
-    """Check if a ~= b (mod period). If either input is an unresolved parameter, returns a == b."""
+    """Check if a ~= b (mod period). If either input is an unresolved parameter, returns a == b.
+
+    Args:
+        a: A Cirq parameter value.
+        b: A Cirq parameter value.
+        period: The parameter period (i.e., cycle time).
+        atol: The absolute tolerance for equality checking.
+
+    Returns:
+        A boolean indicating whether input parameters are approximately equal.
+    """
 
     if cirq.is_parameterized(a) or cirq.is_parameterized(b):
         return a == b
 
     return cirq.all_near_zero_mod(a - b, period, atol=atol)
 
 
@@ -436,15 +446,26 @@
             elif isinstance(gate, ParallelGates):
                 self.component_gates += gate.component_gates
             elif isinstance(gate, cirq.ParallelGate):
                 self.component_gates += gate.num_copies * (gate.sub_gate,)
             else:
                 self.component_gates += (gate,)
 
-    def _qubit_index_to_gate_and_index(self, index: int) -> Tuple[cirq.Gate, int]:
+    def qubit_index_to_gate_and_index(self, index: int) -> Tuple[cirq.Gate, int]:
+        """Gets gate (and index) for the corresponding index.
+
+        Args:
+            index: The index into a particular member of the `ParallelGates` operation.
+
+        Returns:
+            A tuple of the gate at the given index and the index itself.
+
+        Raises:
+            ValueError: If index is outside bounds of gate index range.
+        """
         for gate in self.component_gates:
             if gate.num_qubits() > index >= 0:
                 return gate, index
             index -= gate.num_qubits()
         raise ValueError("index out of range")
 
     def qubit_index_to_equivalence_group_key(self, index: int) -> int:
@@ -455,15 +476,15 @@
 
         Args:
             index: The qubit index.
 
         Returns:
             Equivalence group key.
         """
-        indexed_gate, index_in_gate = self._qubit_index_to_gate_and_index(index)
+        indexed_gate, index_in_gate = self.qubit_index_to_gate_and_index(index)
         if indexed_gate.num_qubits() == 1:
             # find the first instance of the same gate
             first_instance = self.component_gates.index(indexed_gate)
             return sum(map(cirq.num_qubits, self.component_gates[:first_instance]))
         if isinstance(indexed_gate, cirq.InterchangeableQubitsGate):
             gate_key = indexed_gate.qubit_index_to_equivalence_group_key(index_in_gate)
             for i in range(index_in_gate):
@@ -620,20 +641,28 @@
         """
         super().__init__(
             exponent=theta / _pi(theta), phase_exponent=phi / _pi(phi), global_shift=-0.5
         )
 
     @property
     def phi(self) -> cirq.TParamVal:
-        """Angle (in radians) defining the axis of rotation in the `X`-`Y` plane."""
+        """Angle (in radians) defining the axis of rotation in the `X`-`Y` plane.
+
+        Returns:
+            The phi rotation angle.
+        """
         return self.phase_exponent * _pi(self.phase_exponent)
 
     @property
     def theta(self) -> cirq.TParamVal:
-        """Angle (in radians) by which to rotate."""
+        """Angle (in radians) by which to rotate about the axis given by `self.phi`.
+
+        Returns:
+            The theta rotation angle.
+        """
         return self.exponent * _pi(self.exponent)
 
     def __pow__(self, power: cirq.TParamVal) -> "RGate":
         return RGate(power * self.theta, self.phi)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.PhasedXPowGate"""
@@ -687,34 +716,55 @@
             num_copies: Number of copies to be used.
         """
         super().__init__(css.RGate(theta, phi), num_copies)
         self._sub_gate: RGate
 
     @property
     def sub_gate(self) -> RGate:
+        """The gate that is applied to the specified subspace.
+
+        Returns:
+            The underlying gate used.
+        """
         return self._sub_gate
 
     @property
     def phase_exponent(self) -> cirq.TParamVal:
-        """The `phase_exponent` property of each `RGate`."""
+        """The `phase_exponent` property of each `RGate`.
+
+        Returns:
+            The phase exponent.
+        """
         return self.sub_gate.phase_exponent
 
     @property
     def exponent(self) -> cirq.TParamVal:
-        """The `exponent` property of `ParallelRGate`."""
+        """The `exponent` property of `ParallelRGate`.
+
+        Returns:
+            The sub gate exponent.
+        """
         return self.sub_gate.exponent
 
     @property
     def phi(self) -> cirq.TParamVal:
-        """The `phi` property of `ParallelRGate`."""
+        """The `phi` property of `ParallelRGate`, defining orientation (i.e., axis of rotation).
+
+        Returns:
+            The rotation-axis angle phi.
+        """
         return self.sub_gate.phi
 
     @property
     def theta(self) -> cirq.TParamVal:
-        """The `theta` property of `ParallelRGate`."""
+        """The `theta` property of `ParallelRGate`, angle to rotate about the phi-determined axis.
+
+        Returns:
+            The rotation angle theta.
+        """
         return self.sub_gate.theta
 
     def __pow__(self, power: cirq.TParamVal) -> "ParallelRGate":
         return ParallelRGate(power * self.theta, self.phi, self.num_copies)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.ParallelGate"""
@@ -801,15 +851,19 @@
         Args:
             rz_rads: The RZ-rotation angle in radians.
         """
         self._rz_rads = rz_rads
 
     @property
     def rz_rads(self) -> cirq.TParamVal:
-        """The RZ-rotation angle for the gate."""
+        """The RZ-rotation angle in radians for the gate.
+
+        Returns:
+            The angle for the RZ rotation.
+        """
         return self._rz_rads
 
     def _num_qubits_(self) -> int:
         return 2
 
     def _unitary_(self) -> Optional[npt.NDArray[np.complex_]]:
         if self._is_parameterized_():
```

## cirq_superstaq/ops/qudit_gates.py

```diff
@@ -14,15 +14,19 @@
     """A (non-parametrized) SWAP gate on two qudits of arbitrary dimension."""
 
     def __init__(self, dimension: int) -> None:
         self._dimension = dimension
 
     @property
     def dimension(self) -> int:
-        """The qudit dimension on which this SWAP gate will act."""
+        """The qudit dimension on which this SWAP gate will act.
+
+        Returns:
+            The qudit dimension.
+        """
         return self._dimension
 
     def _qid_shape_(self) -> Tuple[int, int]:
         return self.dimension, self.dimension
 
     def _value_equality_values_(self) -> int:
         return self.dimension
@@ -87,15 +91,19 @@
 
 
 class BSwapPowGate(cirq.EigenGate, cirq.InterchangeableQubitsGate):
     """iSWAP-like qutrit entangling gate swapping the "11" and "22" states of two qutrits."""
 
     @property
     def dimension(self) -> int:
-        """Indicates that this gate acts on qutrits."""
+        """Indicates that this gate acts on qutrits.
+
+        Returns:
+            The integer `3`, representing the qudit dimension for qutrits.
+        """
         return 3
 
     @property
     def _swapped_states(self) -> Tuple[Tuple[int, int], Tuple[int, int]]:
         return (1, 1), (2, 2)
 
     def _qid_shape_(self) -> Tuple[int, int]:
@@ -169,15 +177,19 @@
     where d is the dimension of the qudits and Ï‰ = exp(2Ï€i/d).
 
     Currently written for qutrits (d = 3), but its implementation should work for any dimension.
     """
 
     @property
     def dimension(self) -> int:
-        """Indicates that this gate acts on qutrits."""
+        """Indicates that this gate acts on qutrits.
+
+        Returns:
+            The integer `3`, representing the qudit dimension for qutrits.
+        """
         return 3
 
     def _qid_shape_(self) -> Tuple[int, int]:
         return self.dimension, self.dimension
 
     def _eigen_components(self) -> List[Tuple[float, npt.NDArray[np.float_]]]:
         eigen_components = []
@@ -352,29 +364,40 @@
         self._qid_shape = tuple(qid_shape)
         self._subspaces = [
             (subspace[0] % d, subspace[1] % d) for subspace, d in zip(subspaces, qid_shape)
         ]
 
     @property
     def sub_gate(self) -> cirq.Gate:
-        """The gate that is applied to the specified subspace."""
+        """The gate that is applied to the specified subspace.
+
+        Returns:
+            The underlying gate used.
+        """
         return self._sub_gate
 
     @property
     def qid_shape(self) -> Tuple[int, ...]:
-        """Specifies the qudit dimension for each of the inputs."""
+        """Specifies the qudit dimension for each of the inputs.
+
+        Returns:
+            The dimensions for the input qudits.
+        """
         return self._qid_shape
 
     @property
     def subspaces(self) -> List[Tuple[int, int]]:
         """A list of subspace indices acted upon.
 
         For instance, a CX on the 0-1 qubit subspace of two qudits would have subspaces of
         [(0, 1), (0, 1)]. The same gate acting on the 1-2 subspaces of both qudits would correspond
         to [(1, 2), (1, 2)].
+
+        Returns:
+            A list of dimensions tuples, specified for each subspace.
         """
         return self._subspaces
 
     def _qid_shape_(self) -> Tuple[int, ...]:
         return self._qid_shape
 
     def _is_parameterized_(self) -> bool:
@@ -491,16 +514,28 @@
 
 
 def qubit_subspace_op(
     sub_op: cirq.Operation,
     qid_shape: Sequence[int],
     subspaces: Optional[Sequence[Tuple[int, int]]] = None,
 ) -> cirq.Operation:
-    """Embed a qubit Operation into a given subspace of a higher-dimensional Operation using
-    `QubitSubspaceGate`.
+    """Embeds a qubit Operation into a given subspace of a higher-dimensional Operation.
+
+    Uses `QubitSubspaceGate`.
+
+    Args:
+        sub_op: The `cirq.Operation` to embed.
+        qid_shape: The dimensions of the subspace.
+        subspaces: The list of all subspaces.
+
+    Returns:
+        A `cirq.Operation` embedding a low-dimensional operation.
+
+    Raises:
+        ValueError: If there is no gate specified for the subspace operation.
     """
     if not sub_op.gate:
         raise ValueError(f"{sub_op} has no gate.")
 
     qudits = [qubit.with_dimension(d) for qubit, d in zip(sub_op.qubits, qid_shape)]
     return QubitSubspaceGate(sub_op.gate, qid_shape, subspaces=subspaces).on(*qudits)
```

## Comparing `cirq_superstaq-0.4.1.dist-info/METADATA` & `cirq_superstaq-0.4.2.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 Metadata-Version: 2.1
 Name: cirq-superstaq
-Version: 0.4.1
+Version: 0.4.2
 Summary: The Cirq module that provides tools and access to Superstaq
 Home-page: https://github.com/Infleqtion/client-superstaq
 Author: Superstaq development team
 Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
 Requires-Dist: cirq (>=1.0.0)
-Requires-Dist: general-superstaq (~=0.4.1)
+Requires-Dist: general-superstaq (~=0.4.2)
 Requires-Dist: qubovert (>=1.2.3)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.4.1) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.4.2) ; extra == 'dev'
 Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'dev'
 Requires-Dist: symengine (<0.10.0) ; extra == 'dev'
 Provides-Extra: examples
 Requires-Dist: notebook (~=6.4.12) ; extra == 'examples'
 Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'examples'
 Requires-Dist: symengine (<0.10.0) ; extra == 'examples'
```

## Comparing `cirq_superstaq-0.4.1.dist-info/RECORD` & `cirq_superstaq-0.4.2.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,25 @@
-cirq_superstaq/__init__.py,sha256=3k89ggq-UI0faFssu36Dy2uKUIgEYnOW7M9IKlPuGJ4,2495
-cirq_superstaq/_version.py,sha256=pMtTmSUht-XtbR_7Doz6bsQqopJJd8rZ8I8zy2HwwoA,22
+cirq_superstaq/__init__.py,sha256=51AW31H9ehDV-qPfngleGKOF0gaCxRgc25SH81_3Ero,2525
+cirq_superstaq/_version.py,sha256=6hfVa12Q-nXyUEXr6SyKpqPEDJW6vlRHyPxlA27PfTs,22
 cirq_superstaq/_version_test.py,sha256=-Wmzugc_ZE6bKbzU36HmcZ49msf9VSrGPqUCAUS72EY,312
-cirq_superstaq/compiler_output.py,sha256=TpLpR3fvPvOls71fRNMsp7spRiLK9KC5_R1KjgaqtII,12248
+cirq_superstaq/compiler_output.py,sha256=m-VXMuZthNr9mXOVJEyqnjEp3Y5fI6UIipV2mdMh1Mk,12266
 cirq_superstaq/compiler_output_test.py,sha256=aQZP7Alaat33CCIS4f1b3NWnFWvink7PSO3FM2jthjw,13843
 cirq_superstaq/daily_integration_test.py,sha256=emBKmE9l5Z9vNOpqENygZJs4tvQKvNLjsjBMM6kfypY,9766
 cirq_superstaq/job.py,sha256=XyTsLr9E-pNnkHQTFsLrxuD0INfLtulXPuc80lYP2Jk,6815
 cirq_superstaq/job_test.py,sha256=fMEIHVMm_bR2WiaH9pBtNUsyvaAxdT606pr7LPFpFqY,6704
 cirq_superstaq/py.typed,sha256=2DnKRKK8fmvD_m6TmNUqVJZBNb2xKGaCjcHkkVpRsMc,68
 cirq_superstaq/sampler.py,sha256=_rFeY-uP6DxXNwmsODu7JfwyBImRp4zGKNVyR8b0lWI,3067
 cirq_superstaq/serialization.py,sha256=SnSJNJhGeQMyOF28QRC1IdiRMs649ibuHSNzMcIg34c,1430
 cirq_superstaq/serialization_test.py,sha256=MqQeiYXqAeU99NKg6jezNzxQL2DSpi8Vjl0nZaG333o,1604
-cirq_superstaq/service.py,sha256=G6Y0he8uIAQZ6C_FMKWrTL9ywoz_9SDIJvHhi4LCO_E,28607
-cirq_superstaq/service_test.py,sha256=v0k3Hn1QX7ZRq_S-gq_K-yNf_XD7Ik-0DXDEHamlM8Q,23128
+cirq_superstaq/service.py,sha256=pdk5XZTIYLqS38K_sgkhdHVpobuhwh6aqPvFcl3agjM,28806
+cirq_superstaq/service_test.py,sha256=36JxKQ48JQb_DwPjHdiFVEQROxGEFNrhYk9GPn9iQtg,22685
+cirq_superstaq/validation.py,sha256=uu_FsoCbCMhyg2i2jNAOlqwdC5aCIO8BUcbRZlJRzAY,743
+cirq_superstaq/validation_test.py,sha256=cvDioZ8ahJyq75ANxmRzrku3_PEIeBm_PWlb-76UpW4,789
 cirq_superstaq/ops/__init__.py,sha256=CsW8WwyPL4jSfiUG3CrukZW-6YR7uOJvTVxiO5e4uiU,1297
-cirq_superstaq/ops/qubit_gates.py,sha256=DPtVT8GQzhjVb_Q4UHQqNkQFf14m_iHGqm1PF2f2p_8,33936
+cirq_superstaq/ops/qubit_gates.py,sha256=JEV3Msf2kql6V1BC98nLQPiHqQara546u03ZXTRAgZc,35310
 cirq_superstaq/ops/qubit_gates_test.py,sha256=8v3YyJsK23uscIu5S93YjPk3h9TRirrIgwGsVb_1Tvs,38578
-cirq_superstaq/ops/qudit_gates.py,sha256=ES9zw1SqNGnQeBQi44qqn4pHcWjOPBr5s0R4HzgkiTQ,19243
+cirq_superstaq/ops/qudit_gates.py,sha256=NTlijrv8kZl2jyJOkvhR2EpgWM4K1PbBi5fjZv7lXSs,20064
 cirq_superstaq/ops/qudit_gates_test.py,sha256=pkQAviY-GsYRUyRVjfK1dWlQ5VjlX_3U3c4VU64y8co,16989
-cirq_superstaq-0.4.1.dist-info/METADATA,sha256=uIOMkFPWKpZg39ciEE4GvGgiP-M0oft0RqsInPGCeTc,2304
-cirq_superstaq-0.4.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cirq_superstaq-0.4.1.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
-cirq_superstaq-0.4.1.dist-info/RECORD,,
+cirq_superstaq-0.4.2.dist-info/METADATA,sha256=b-M0uwJndkhMqFxtu69jXXf-bGoxeLnrwG-YE2HKXQE,2304
+cirq_superstaq-0.4.2.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_superstaq-0.4.2.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
+cirq_superstaq-0.4.2.dist-info/RECORD,,
```

